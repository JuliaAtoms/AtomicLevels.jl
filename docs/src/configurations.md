# Atomic configurations

```@meta
DocTestSetup = quote
    using AtomicLevels
end
```

We define a configuration to be a set of orbitals with their
associated occupation (i.e. the number of electron on that
orbital). We can represent a particular configuration with an instance
of the [`Configuration`](@ref) type. The orbitals of a configuration
can be unsorted (default) or sorted according to the canonical
ordering (first by ``n``, then by ``\ell``, &c). It is important to
allow for arbitrary order, since permutation of the orbitals in a
configuration, in general incurs a phase shift of matrix elements, &c.

```@docs
Configuration
```

The [`@c_str`](@ref) and [`@rc_str`](@ref) string macros can be used to conveniently
construct configurations:

```@docs
@c_str
@rc_str
```

## Interface

For example, it is possible to index into a configuration, including with a range of
indices, returning a sub-configuration consisting of only those orbitals. With an integer
index, an `(orbital, occupancy, state)` tuple is returned.

```jldoctest confexamples
julia> config = c"1s2c 2si 2p3"
[He]ᶜ 2sⁱ 2p³

julia> config[2]
(2s, 1, :inactive)

julia> config[1:2]
[He]ᶜ 2sⁱ

julia> config[[3,1]]
[He]ᶜ 2p³
```

The configuration can also be iterated over. Each item is a `(orbital, occupancy, state)`
tuple.

```jldoctest confexamples
julia> for (o, nelec, s) in config
           @show o, nelec, s
       end
(o, nelec, s) = (1s, 2, :closed)
(o, nelec, s) = (2s, 1, :inactive)
(o, nelec, s) = (2p, 3, :open)
```

Various other methods exist to manipulate or transform configurations or to query them for
information.

```@docs
issimilar
Base.:(==)(a::Configuration{<:O}, b::Configuration{<:O}) where {O<:AbstractOrbital}
num_electrons(::Configuration)
num_electrons(::Configuration, ::AtomicLevels.AbstractOrbital)
Base.delete!
Base.:(+)
Base.:(-)
Base.close
close!
Base.fill
Base.fill!
Base.in
Base.filter
Base.count
Base.replace
core
peel
active
inactive
bound
continuum
parity(::Configuration)
nonrelconfiguration
```

## Generating configuration lists

The [`⊗`](@ref) operator can be used to easily generate lists of configurations from existing
pieces. E.g. to create all the valence configurations on top of an closed core, you only
need to write

```jldoctest
julia> c"[Ne]" ⊗ [c"3s2", c"3s 3p", c"3p2"]
3-element Array{Configuration{Orbital{Int64}},1}:
 [Ne]ᶜ 3s²
 [Ne]ᶜ 3s 3p
 [Ne]ᶜ 3p²
```

That can be combined with the [`@rcs_str`](@ref) string macro to easily generate all possible
relativistic configurations from a non-relativistic definition:

```jldoctest
julia> rc"[Ne] 3s2" ⊗ rcs"3p2"
3-element Array{Configuration{RelativisticOrbital{Int64}},1}:
 [Ne]ᶜ 3s² 3p⁻²
 [Ne]ᶜ 3s² 3p⁻ 3p
 [Ne]ᶜ 3s² 3p²
```

```@docs
⊗
@rcs_str
```

## Spin configurations

```@docs
SpinConfiguration
spin_configurations
substitutions
@scs_str
```

## Excited configurations

AtomicLevels.jl provides an easy interface for generating lists of
configurations which are the result of exciting one or more orbitals
of a reference set to a set of substitution orbitals. This is done
with [`excited_configurations`](@ref), which provides various
parameters for controlling which excitations are generated. A very
simple example could be

```jldoctest
julia> excited_configurations(c"1s2", os"2[s-p]"...)
4-element Array{Configuration{Orbital{Int64}},1}:
 1s²
 1s 2s
 2s²
 2p²
```

which as we see contains all configurations generated by at most
exciting two orbitals `1s²` and keeping the overall parity. By lifting
these restrictions, more configurations can be generated:

```jldoctest
julia> excited_configurations(c"1s2 2s", os"3[s-p]"...,
                              keep_parity=false, max_excitations=2)
14-element Array{Configuration{Orbital{Int64}},1}:
 1s² 2s
 1s 2s²
 1s 2s 3s
 1s 2s 3p
 1s² 3s
 1s² 3p
 2s² 3s
 2s² 3p
 2s 3s²
 2s 3s 3p
 1s 3s²
 1s 3s 3p
 2s 3p²
 1s 3p²

julia> excited_configurations(c"1s2 2s", os"3[s-p]"...,
                              keep_parity=false, max_excitations=3)
17-element Array{Configuration{Orbital{Int64}},1}:
 1s² 2s
 1s 2s²
 1s 2s 3s
 1s 2s 3p
 1s² 3s
 1s² 3p
 2s² 3s
 2s² 3p
 2s 3s²
 2s 3s 3p
 1s 3s²
 1s 3s 3p
 2s 3p²
 1s 3p²
 3s² 3p
 3s 3p²
 3p³
```

Since configurations by default are unsorted, when exciting from
[`SpinConfiguration`](@ref)s, the substitutions are performed
in-place:

```jldoctest
julia> excited_configurations(first(scs"1s2"), sos"2[s-p]"...)
21-element Array{Configuration{SpinOrbital{Orbital{Int64}}},1}:
 1s₀α 1s₀β
 2s₀α 1s₀β
 2s₀β 1s₀β
 1s₀α 2s₀α
 1s₀α 2s₀β
 2s₀α 2s₀β
 2p₋₁α 2p₋₁β
 2p₋₁α 2p₀α
 2p₋₁α 2p₀β
 2p₋₁α 2p₁α
 2p₋₁α 2p₁β
 2p₋₁β 2p₀α
 2p₋₁β 2p₀β
 2p₋₁β 2p₁α
 2p₋₁β 2p₁β
 2p₀α 2p₀β
 2p₀α 2p₁α
 2p₀α 2p₁β
 2p₀β 2p₁α
 2p₀β 2p₁β
 2p₁α 2p₁β
```

```@docs
excited_configurations
```

```@meta
DocTestSetup = nothing
```
