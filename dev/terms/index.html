<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Term symbols · AtomicLevels</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script src="../assets/latex.js"></script></head><body><nav class="toc"><h1>AtomicLevels</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../orbitals/">Orbitals</a></li><li><a class="toctext" href="../configurations/">Configurations</a></li><li class="current"><a class="toctext" href>Term symbols</a><ul class="internal"><li><a class="toctext" href="#Term-multiplicity-and-intermediate-terms-1">Term multiplicity and intermediate terms</a></li><li><a class="toctext" href="#Term-couplings-1">Term couplings</a></li></ul></li><li><a class="toctext" href="../csfs/">CSFs</a></li><li><a class="toctext" href="../utilities/">Other utilities</a></li><li><a class="toctext" href="../internals/">Internals</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Term symbols</a></li></ul><a class="edit-page" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/master/docs/src/terms.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Term symbols</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Term-symbols-1" href="#Term-symbols-1">Term symbols</a></h1><p>AtomicLevels provides types and methods to work and determine term symbols. The <a href="https://en.wikipedia.org/wiki/Term_symbol">&quot;Term symbol&quot;</a> and <a href="https://en.wikipedia.org/wiki/Angular_momentum_coupling">&quot;Angular momentum coupling&quot;</a> Wikipedia articles give a good basic overview of the terminology.</p><p>For term symbols in LS coupling, AtomicLevels provides the <a href="#AtomicLevels.Term"><code>Term</code></a> type.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.Term" href="#AtomicLevels.Term"><code>AtomicLevels.Term</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct Term</code></pre><p>Represents a term symbol with specific parity in LS-coupling.</p><p>Only the <span>$L$</span>, <span>$S$</span> and parity values of the symbol <span>${}^{2S+1}L_{J}$</span> are specified. To specify a <em>level</em>, the <span>$J$</span> value would have to be specified separately. The valid <span>$J$</span> values corresponding to given <span>$L$</span> and <span>$S$</span> fall in the following range:</p><div>\[|L - S| \leq J \leq L+S\]</div><p><strong>Constructors</strong></p><pre><code class="language-none">Term(L::Real, S::Real, parity::Union{Parity,Integer})</code></pre><p>Constructs a <code>Term</code> object with the given <span>$L$</span> and <span>$S$</span> quantum numbers and parity. <code>L</code> and <code>S</code> both have to be convertible to <code>HalfInteger</code>s and <code>parity</code> must be of type <a href="../utilities/#AtomicLevels.Parity"><code>Parity</code></a> or <code>±1</code>.</p><p>See also: <a href="#AtomicLevels.@T_str"><code>@T_str</code></a></p><p><strong>Properties</strong></p><p>To access the quantum number values, you can use the <code>.L</code>, <code>.S</code> and <code>.parity</code> properties to access the <span>$L$</span>, <span>$S$</span> and parity values (represented with <a href="../utilities/#AtomicLevels.Parity"><code>Parity</code></a>), respectively. E.g.:</p><pre><code class="language-julia-repl">julia&gt; t = Term(2, 1//2, p&quot;odd&quot;)
²Dᵒ

julia&gt; t.L, t.S, t.parity
(2, 1/2, odd)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/terms.jl#L3-L39">source</a></section><p>The <a href="#AtomicLevels.Term"><code>Term</code></a> objects can also be constructed with the <a href="#AtomicLevels.@T_str"><code>@T_str</code></a> string macro.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.@T_str" href="#AtomicLevels.@T_str"><code>AtomicLevels.@T_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@T_str -&gt; Term</code></pre><p>Constructs a <a href="#AtomicLevels.Term"><code>Term</code></a> object out of its canonical string representation.</p><pre><code class="language-julia-repl">julia&gt; T&quot;1S&quot;
¹S

julia&gt; T&quot;4Po&quot;
⁴Pᵒ

julia&gt; T&quot;2[3/2]o&quot; # jK coupling, common in noble gases
²[3/2]ᵒ</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/terms.jl#L87-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parse-Tuple{Type{Term},AbstractString}" href="#Base.parse-Tuple{Type{Term},AbstractString}"><code>Base.parse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">parse(::Type{Term}, ::AbstractString) -&gt; Term</code></pre><p>Parses a string into a <a href="#AtomicLevels.Term"><code>Term</code></a> object.</p><pre><code class="language-julia-repl">julia&gt; parse(Term, &quot;4Po&quot;)
⁴Pᵒ</code></pre><p>See also: <a href="#AtomicLevels.@T_str"><code>@T_str</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/terms.jl#L53-L64">source</a></section><p>The <a href="#AtomicLevels.terms"><code>terms</code></a> function can be used to generate all possible term symbols. In the case of relativistic orbitals, the term symbols are simply the valid <span>$J$</span> values, represented using the <a href="https://github.com/sostock/HalfIntegers.jl"><code>HalfInteger</code></a> type.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.terms" href="#AtomicLevels.terms"><code>AtomicLevels.terms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">terms(orb::Orbital, w::Int=one(Int))</code></pre><p>Returns a list of valid LS term symbols for the orbital <code>orb</code> with <code>w</code> occupancy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; terms(o&quot;3d&quot;, 3)
8-element Array{Term,1}:
 ²P
 ²D
 ²D
 ²F
 ²G
 ²H
 ⁴P
 ⁴F</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/terms.jl#L163-L183">source</a><div><div><pre><code class="language-none">terms(config)</code></pre><p>Generate all final <span>$LS$</span> terms for <code>config</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; terms(c&quot;1s&quot;)
1-element Array{Term,1}:
 ²S

julia&gt; terms(c&quot;1s 2p&quot;)
2-element Array{Term,1}:
 ¹Pᵒ
 ³Pᵒ

julia&gt; terms(c&quot;[Ne] 3d3&quot;)
7-element Array{Term,1}:
 ²P
 ²D
 ²F
 ²G
 ²H
 ⁴P
 ⁴F</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/terms.jl#L202-L229">source</a><div><div><pre><code class="language-none">terms(o::RelativisticOrbital, w = 1) -&gt; Vector{HalfInt}</code></pre><p>Returns a sorted list of valid <span>$J$</span> values of <code>w</code> equivalent <span>$jj$</span>-coupled particles on orbital <code>o</code> (i.e. <code>oʷ</code>).</p><p>When there are degeneracies (i.e. multiple states with the same <span>$J$</span> and <span>$M$</span> quantum numbers), the corresponding <span>$J$</span> value is repeated in the output array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; terms(ro&quot;3d&quot;, 3)
3-element Array{HalfIntegers.Half{Int64},1}:
 3/2
 5/2
 9/2

julia&gt; terms(ro&quot;3d-&quot;, 3)
1-element Array{HalfIntegers.Half{Int64},1}:
 3/2

julia&gt; terms(ro&quot;4f&quot;, 4)
8-element Array{HalfIntegers.Half{Int64},1}:
 0
 2
 2
 4
 4
 5
 6
 8</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/jj_terms.jl#L1-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.count_terms" href="#AtomicLevels.count_terms"><code>AtomicLevels.count_terms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">count_terms(orbital, occupation, term)</code></pre><p>Count how many times <code>term</code> occurs among the valid terms of <code>orbital^occupation</code>.</p><pre><code class="language-julia-repl">julia&gt; count_terms(o&quot;1s&quot;, 2, T&quot;1S&quot;)
1

julia&gt; count_terms(ro&quot;6h&quot;, 4, 8)
4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/terms.jl#L238-L250">source</a></section><h2><a class="nav-anchor" id="Term-multiplicity-and-intermediate-terms-1" href="#Term-multiplicity-and-intermediate-terms-1">Term multiplicity and intermediate terms</a></h2><p>For subshells starting with <code>d³</code>, a term symbol can occur multiple times, each occurrence corresponding to a different physical state (multiplicity higher than one). This happens when there are distinct ways of coupling the electrons, but they yield the same total angular momentum. E.g. a <code>d³</code> subshell can be coupled in 8 different ways, two of which are both described by the <code>²D</code> term symbol:</p><pre><code class="language-julia-repl">julia&gt; terms(o&quot;3d&quot;, 3)
8-element Array{Term,1}:
 ²P
 ²D
 ²D
 ²F
 ²G
 ²H
 ⁴P
 ⁴F

julia&gt; count_terms(o&quot;3d&quot;, 3, T&quot;2D&quot;)
2</code></pre><p>The multiplicity can be even higher if more electrons and higher angular momenta are involved:</p><pre><code class="language-julia-repl">julia&gt; count_terms(o&quot;4f&quot;, 5, T&quot;2Do&quot;)
5</code></pre><p>To distinguish these subshells, extra quantum numbers must be specified. In AtomicLevels, that can be done with the <a href="#AtomicLevels.IntermediateTerm"><code>IntermediateTerm</code></a> type. This is primarily used when specifying the subshell couplings in <a href="../csfs/#CSFs-1">CSFs</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.IntermediateTerm" href="#AtomicLevels.IntermediateTerm"><code>AtomicLevels.IntermediateTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct IntermediateTerm{T,S}</code></pre><p>Represents a term together with its extra disambiguating quantum number(s), labelled by <code>ν</code>.</p><p>The term symbol (<code>::T</code>) can either be a <a href="#AtomicLevels.Term"><code>Term</code></a> (for <span>$LS$</span>-coupling) or a <code>HalfInteger</code> (for <span>$jj$</span>-coupling).</p><p>The disambiguating quantum number(s) (<code>::S</code>) can be anything as long as they are sortable (i.e. implementing <code>isless</code>). It is up to the user to pick a scheme that is suitable for their application. See &quot;<a href="#Disambiguating-quantum-numbers-1">Disambiguating quantum numbers</a>&quot; in the manual for discussion on how it is used in AtomicLevels.</p><p>See also: <a href="#AtomicLevels.Term"><code>Term</code></a>, <a href="#AtomicLevels.Seniority"><code>Seniority</code></a></p><p><strong>Constructors</strong></p><pre><code class="language-none">IntermediateTerm(term, ν)</code></pre><p>Constructs an intermediate term with the term symbol <code>term</code> and disambiguating quantum number(s) <code>ν</code>.</p><p><strong>Properties</strong></p><p>To access the term symbol and the disambiguating quantum number(s), you can use the <code>.term :: T</code> and <code>.ν :: S</code> (or <code>.nu :: S</code>) properties, respectively. E.g.:</p><pre><code class="language-julia-repl">julia&gt; it = IntermediateTerm(T&quot;2D&quot;, 2)
₍₂₎²D

julia&gt; it.term, it.ν
(²D, 2)

julia&gt; it = IntermediateTerm(5//2, Seniority(2))
₂5/2

julia&gt; it.term, it.nu
(5/2, ₂)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/intermediate_terms.jl#L63-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.intermediate_terms" href="#AtomicLevels.intermediate_terms"><code>AtomicLevels.intermediate_terms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intermediate_terms(orb::Orbital, w::Int=one(Int))</code></pre><p>Generates all <a href="#AtomicLevels.IntermediateTerm"><code>IntermediateTerm</code></a> for a given non-relativstic orbital <code>orb</code> and occupation <code>w</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; intermediate_terms(o&quot;2p&quot;, 2)
3-element Array{IntermediateTerm,1}:
 ₀¹S
 ₂¹D
 ₂³P</code></pre><p>The preceding subscript is the seniority number, which indicates at which occupancy a certain term is first seen, cf.</p><pre><code class="language-julia-repl">julia&gt; intermediate_terms(o&quot;3d&quot;, 1)
1-element Array{IntermediateTerm,1}:
 ₁²D

julia&gt; intermediate_terms(o&quot;3d&quot;, 3)
8-element Array{IntermediateTerm,1}:
 ₁²D
 ₃²P
 ₃²D
 ₃²F
 ₃²G
 ₃²H
 ₃⁴P
 ₃⁴F</code></pre><p>In the second case, we see both <code>₁²D</code> and <code>₃²D</code>, since there are two ways of coupling 3 <code>d</code> electrons to a <code>²D</code> symmetry.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/intermediate_terms.jl#L132-L170">source</a><div><div><pre><code class="language-none">intermediate_terms(config)</code></pre><p>Generate the intermediate terms for each subshell of <code>config</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; intermediate_terms(c&quot;1s 2p3&quot;)
2-element Array{Array{IntermediateTerm,1},1}:
 [₁²S]
 [₁²Pᵒ, ₃²Dᵒ, ₃⁴Sᵒ]

julia&gt; intermediate_terms(rc&quot;3d2 5g3&quot;)
2-element Array{Array{HalfIntegers.Half{Int64},1},1}:
 [0, 2, 4]
 [3/2, 5/2, 7/2, 9/2, 9/2, 11/2, 13/2, 15/2, 17/2, 21/2]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/intermediate_terms.jl#L191-L209">source</a></section><h3><a class="nav-anchor" id="Disambiguating-quantum-numbers-1" href="#Disambiguating-quantum-numbers-1">Disambiguating quantum numbers</a></h3><p>The <a href="#AtomicLevels.IntermediateTerm"><code>IntermediateTerm</code></a> type does not specify how to interpret the disambiguating quantum number(s) <span>$ν$</span>, or even what the type of it should be. In AtomicLevels, we use two different types, depending on the situation:</p><ul><li><p><strong>A simple <code>Integer</code>.</strong> In this case, the quantum number <span>$\nu$</span> must be in the range <span>$1 \leq \nu \leq N_{\rm{terms}}$</span>, where <span>$N_{\rm{terms}}$</span> is the multiplicity of the term symbol (i.e. the number of times this term symbol appears for this subshell <span>$\ell^w$</span> or <span>$\ell_j^w$</span>).</p><p>AtomicLevels does not prescribe any further interpretation for the quantum number. It can be used as a simple counter to distinguish the different terms, or the user can define their own mapping from the set of integers to physical states.</p></li><li><p><strong><code>Seniority</code>.</strong> In this case the number is interpreted to be <em>Racah&#39;s seniority number</em>. This gives the intermediate term a specific physical interpretation, but only works for certain subshells. See the <a href="#AtomicLevels.Seniority"><code>Seniority</code></a> type for more information.</p></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.Seniority" href="#AtomicLevels.Seniority"><code>AtomicLevels.Seniority</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Seniority(ν)</code></pre><p>Seniority is an extra quantum number introduced by Giulio Racah (1943) to disambiguate between terms belonging to a subshell with a specific occupancy, that are assigned the same term symbols. For partially filled f-shells (in <span>$LS$</span> coupling) or partially filled <span>$9/2$</span> shells (in <span>$jj$</span> coupling), seniority alone is not enough to disambiguate all the arising terms.</p><p>The seniority number is defined as the minimum occupancy number <code>ν ∈ n:-2:0</code> for which the term first appears, e.g. the ²D term first occurs in the d¹ configuration, then twice in the d³ configuration (which will then have the terms ₁²D and ₃²D).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/intermediate_terms.jl#L3-L17">source</a></section><h3><a class="nav-anchor" id="Internal-implementation-of-term-multiplicity-calculation-1" href="#Internal-implementation-of-term-multiplicity-calculation-1">Internal implementation of term multiplicity calculation</a></h3><p>AtomicLevels.jl uses the algorithm presented in</p><ul><li><em>Alternative mathematical technique to determine LS spectral terms</em> by Xu Renjun and Dai Zhenwen, published in JPhysB, 2006. <a href="https://dx.doi.org/10.1088/0953-4075/39/16/007">doi:10.1088/0953-4075/39/16/007</a></li></ul><p>to compute the multiplicity of individual subshells in <span>$LS$</span>-coupling, beyond the trivial cases of a single electron or a filled subshell. These routines need not be used directly, instead use <a href="#AtomicLevels.terms"><code>terms</code></a> and <a href="#AtomicLevels.count_terms"><code>count_terms</code></a>.</p><p>In the following, <span>$S&#39;=2S\in\mathbb{Z}$</span> and <span>$M_S&#39;=2M_S\in\mathbb{Z}$</span>, as in the original article.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.xu_terms" href="#AtomicLevels.xu_terms"><code>AtomicLevels.xu_terms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">xu_terms(ℓ, w, p)</code></pre><p>Return all term symbols for the orbital <code>ℓʷ</code> and parity <code>p</code>; the term multiplicity is computed using <a href="#AtomicLevels.Xu.X"><code>AtomicLevels.Xu.X</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; AtomicLevels.xu_terms(3, 3, parity(c&quot;3d3&quot;))
17-element Array{Term,1}:
 ²P
 ²D
 ²D
 ²F
 ²F
 ²G
 ²G
 ²H
 ²H
 ²I
 ²K
 ²L
 ⁴S
 ⁴D
 ⁴F
 ⁴G
 ⁴I</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/terms.jl#L125-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.Xu.X" href="#AtomicLevels.Xu.X"><code>AtomicLevels.Xu.X</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">X(N, ℓ, S′, L)</code></pre><p>Calculate the multiplicity of the term <span>$^{2S+1}L$</span> (<span>$S&#39;=2S$</span>) for the orbital <code>ℓ</code> with occupancy <code>N</code>, according to the formula:</p><div>\[\begin{aligned}
X(N, \ell, S&#39;, L) =&amp;+ A(N, \ell,\ell,S&#39;,L)\\
&amp;- A(N, \ell,\ell,S&#39;,L+1)\\
&amp;+A(N, \ell,\ell,S&#39;+2,L+1)\\
&amp;- A(N, \ell,\ell,S&#39;+2,L)
\end{aligned}\]</div><p>Note that this is not correct for filled (empty) shells, for which the only possible term trivially is <code>¹S</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; AtomicLevels.Xu.X(1, 0, 1, 0) # Multiplicity of ²S term for s¹
1

julia&gt; AtomicLevels.Xu.X(3, 3, 1, 3) # Multiplicity of ²D term for d³
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/xu2006.jl#L87-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.Xu.A" href="#AtomicLevels.Xu.A"><code>AtomicLevels.Xu.A</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><span>$A(N,\ell,\ell_b,M_S&#39;,M_L)$</span> obeys four different cases:</p><p><strong>Case 1</strong></p><p><span>$M_S&#39;=1$</span>, <span>$|M_L|\leq\ell$</span>, and <span>$N=1$</span>:</p><div>\[A(1,\ell,\ell_b,1,M_L) = 1\]</div><p><strong>Case 2</strong></p><p><span>$\{M_S&#39;\}={2-N,4-N,...,N-2}$</span>, <span>$|M_L| \leq f\left(\frac{N-M_S&#39;}{2}-1\right)+f\left(\frac{N+M_S&#39;}{2}-1\right)$</span>, and <span>$1&lt;N\leq 2\ell+1$</span>:</p><div>\[\begin{aligned}
A(N,\ell,\ell,M_S&#39;,M_L) =
\sum_{M_{L-}\max\left\{-f\left(\frac{N-M_S&#39;}{2}-1\right),M_L-f\left(\frac{N+M_S&#39;}{2}-1\right)\right\}}
^{\min\left\{f\left(\frac{N-M_S&#39;}{2}-1\right),M_L+f\left(\frac{N+M_S&#39;}{2}-1\right)\right\}}
\Bigg\{A\left(\frac{N-M_S&#39;}{2},\ell,\ell,\frac{N-M_S&#39;}{2},M_{L-}\right)\\
\times
A\left(\frac{N+M_S&#39;}{2},\ell,\ell,\frac{N+M_S&#39;}{2},M_L-M_{L-}\right)\Bigg\}
\end{aligned}\]</div><p><strong>Case 3</strong></p><p><span>$M_S&#39;=N$</span>, <span>$|M_L|\leq f(N-1)$</span>, and <span>$1&lt;N\leq 2\ell+1$</span>:</p><div>\[A(N,\ell,\ell_b,N,M_L) =
\sum_{M_{L_I} = \left\lfloor{\frac{M_L-1}{N}+\frac{N+1}{2}}\right\rfloor}
^{\min\{\ell_b,M_L+f(N-2)\}}
A(N-1,\ell,M_{L_I}-1,N-1,M_L-M_{L_I})\]</div><p><strong>Case 4</strong></p><p>else:</p><div>\[A(N,\ell,\ell_b,M_S&#39;,M_L) = 0\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/xu2006.jl#L15-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.Xu.f" href="#AtomicLevels.Xu.f"><code>AtomicLevels.Xu.f</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">f(n,ℓ)</code></pre><div>\[f(n,\ell)=\begin{cases}
\displaystyle\sum_{m=0}^n \ell-m, &amp; n\geq0\\
0, &amp; n&lt;0
\end{cases}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/xu2006.jl#L3-L12">source</a></section><h2><a class="nav-anchor" id="Term-couplings-1" href="#Term-couplings-1">Term couplings</a></h2><p>The angular momentum coupling method is based on the <a href="https://en.wikipedia.org/wiki/Vector_model_of_the_atom">vector model</a>, where two angular momenta can be combined via vector addition to form a total angular momentum:</p><div>\[\vec{J} = \vec{L} + \vec{S},\]</div><p>where the length of the resultant momentum <span>$\vec{J}$</span> obeys</p><div>\[|L-S| \leq J \leq L+S.\]</div><p>Relations such as these are used to couple the term symbols in both <span>$LS$</span> and <span>$jj$</span> coupling; however, not all values of <span>$J$</span> predicted by the vector model are valid physical states, see <a href="#AtomicLevels.couple_terms"><code>couple_terms</code></a>.</p><p>To generate the possible <a href="#AtomicLevels.terms"><code>terms</code></a> of a configuration, all the possible terms of the individual subshells, have to be coupled together to form the final terms; this is done from left-to-right. When generating all possible <a href="../csfs/#CSFs-1"><code>CSFs</code></a> from a configuration, it is also necessary to find the intermediate couplings of the individual subshells. As an example, if we want to find the possible terms of <code>3p² 4s 5p²</code>, we first find the possible terms of the individual subshells:</p><pre><code class="language-julia-repl">julia&gt; its = intermediate_terms(c&quot;3p2 4s 5p2&quot;)
3-element Array{Array{IntermediateTerm,1},1}:
 [₀¹S, ₂¹D, ₂³P]
 [₁²S]
 [₀¹S, ₂¹D, ₂³P]</code></pre><p>where the seniority numbers are indicated as preceding subscripts. We then need to couple each intermediate term of the first subshell with each of the second subshell, and couple each of the resulting terms with each of the third subshell, and so on. E.g. coupling the <code>₂³P</code> intermediate term with <code>₁²S</code> produces two terms:</p><pre><code class="language-julia-repl">julia&gt; couple_terms(T&quot;3P&quot;, T&quot;2S&quot;)
2-element Array{Term,1}:
 ²P
 ⁴P</code></pre><p>each of which need to be coupled with e.g. <code>₂¹D</code>:</p><pre><code class="language-julia-repl">julia&gt; couple_terms(T&quot;2P&quot;, T&quot;1D&quot;)
3-element Array{Term,1}:
 ²P
 ²D
 ²F

julia&gt; couple_terms(T&quot;4P&quot;, T&quot;1D&quot;)
3-element Array{Term,1}:
 ⁴P
 ⁴D
 ⁴F</code></pre><p><a href="#AtomicLevels.terms"><code>terms</code></a> uses <a href="#AtomicLevels.couple_terms"><code>couple_terms</code></a> (through <a href="#AtomicLevels.final_terms"><code>AtomicLevels.final_terms</code></a>) to produce all possible terms coupling trees, folding from left-to-right:</p><pre><code class="language-julia-repl">julia&gt; a = couple_terms([T&quot;1S&quot;, T&quot;1D&quot;, T&quot;3P&quot;], [T&quot;2S&quot;])
4-element Array{Term,1}:
 ²S
 ²P
 ²D
 ⁴P

julia&gt; couple_terms(a, [T&quot;1S&quot;, T&quot;1D&quot;, T&quot;3P&quot;])
12-element Array{Term,1}:
 ²S
 ²P
 ²D
 ²F
 ²G
 ⁴S
 ⁴P
 ⁴D
 ⁴F
 ⁶S
 ⁶P
 ⁶D</code></pre><p>which gives the same result as</p><pre><code class="language-julia-repl">julia&gt; terms(c&quot;3p2 4s 5p2&quot;)
12-element Array{Term,1}:
 ²S
 ²P
 ²D
 ²F
 ²G
 ⁴S
 ⁴P
 ⁴D
 ⁴F
 ⁶S
 ⁶P
 ⁶D</code></pre><p>Note that for the generation of final terms, the intermediate terms need not be kept (and their seniority is not important). However, for the generation of <a href="../csfs/#CSFs-1"><code>CSFs</code></a>, we need to form all possible combinations of intermediate terms for each subshell, and couple them, again left-to-right, to form all possible coupling chains (each one corresponding to a unique physical state). E.g. for the last term of each subshell of <code>3p² 4s 5p²</code></p><pre><code class="language-julia-repl">julia&gt; last.(its)
3-element Array{IntermediateTerm,1}:
 ₂³P
 ₁²S
 ₂³P</code></pre><p>we find the following chains:</p><pre><code class="language-julia-repl">julia&gt; intermediate_couplings(last.(its))
15-element Array{Array{Term,1},1}:
 [¹S, ³P, ²P, ²S]
 [¹S, ³P, ²P, ²P]
 [¹S, ³P, ²P, ²D]
 [¹S, ³P, ²P, ⁴S]
 [¹S, ³P, ²P, ⁴P]
 [¹S, ³P, ²P, ⁴D]
 [¹S, ³P, ⁴P, ²S]
 [¹S, ³P, ⁴P, ²P]
 [¹S, ³P, ⁴P, ²D]
 [¹S, ³P, ⁴P, ⁴S]
 [¹S, ³P, ⁴P, ⁴P]
 [¹S, ³P, ⁴P, ⁴D]
 [¹S, ³P, ⁴P, ⁶S]
 [¹S, ³P, ⁴P, ⁶P]
 [¹S, ³P, ⁴P, ⁶D]</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.couple_terms" href="#AtomicLevels.couple_terms"><code>AtomicLevels.couple_terms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">couple_terms(t1, t2)</code></pre><p>Generate all possible coupling terms between <code>t1</code> and <code>t2</code>.  It is assumed that <code>t1</code> and <code>t2</code> originate from non-equivalent electrons (i.e. from <em>different</em> subshells), since the vector model does not predict correct term couplings for equivalent electrons; some of the generated terms would violate the Pauli principle; cf. Cowan p. 108–109.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; couple_terms(T&quot;1Po&quot;, T&quot;2Se&quot;)
1-element Array{Term,1}:
 ²Pᵒ

julia&gt; couple_terms(T&quot;3Po&quot;, T&quot;2Se&quot;)
2-element Array{Term,1}:
 ²Pᵒ
 ⁴Pᵒ

julia&gt; couple_terms(T&quot;3Po&quot;, T&quot;2De&quot;)
6-element Array{Term,1}:
 ²Pᵒ
 ²Dᵒ
 ²Fᵒ
 ⁴Pᵒ
 ⁴Dᵒ
 ⁴Fᵒ</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/couple_terms.jl#L1-L32">source</a><div><div><pre><code class="language-none">couple_terms(t1s, t2s)</code></pre><p>Generate all coupling between all terms in <code>t1s</code> and all terms in <code>t2s</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/couple_terms.jl#L43-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.final_terms" href="#AtomicLevels.final_terms"><code>AtomicLevels.final_terms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">final_terms(ts::Vector{&lt;:Vector{&lt;:Union{Term,Real}}})</code></pre><p>Generate all possible final terms from the vector of vectors of individual subshell terms by coupling from left to right.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ts = [[T&quot;1S&quot;, T&quot;3S&quot;], [T&quot;2P&quot;, T&quot;2D&quot;]]
2-element Array{Array{Term,1},1}:
 [¹S, ³S]
 [²P, ²D]

julia&gt; AtomicLevels.final_terms(ts)
4-element Array{Term,1}:
 ²P
 ²D
 ⁴P
 ⁴D</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/couple_terms.jl#L58-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AtomicLevels.intermediate_couplings" href="#AtomicLevels.intermediate_couplings"><code>AtomicLevels.intermediate_couplings</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intermediate_couplings(its::Vector{IntermediateTerm,Integer,HalfInteger}, t₀ = T&quot;1S&quot;)</code></pre><p>Generate all intermediate coupling trees from the vector of intermediate terms <code>its</code>, starting from the initial term <code>t₀</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; intermediate_couplings([IntermediateTerm(T&quot;2S&quot;, 1), IntermediateTerm(T&quot;2D&quot;, 1)])
2-element Array{Array{Term,1},1}:
 [¹S, ²S, ¹D]
 [¹S, ²S, ³D]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/couple_terms.jl#L103-L117">source</a><div><div><pre><code class="language-none">intermediate_couplings(J::Vector{&lt;:Real}, j₀ = 0)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; intermediate_couplings([1//2, 3//2])
2-element Array{Array{HalfIntegers.Half{Int64},1},1}:
 [0, 1/2, 1]
 [0, 1/2, 2]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/AtomicLevels.jl/blob/49e616381a297ad3f9896211f9ff415d3c67b194/src/couple_terms.jl#L121-L132">source</a></section><footer><hr/><a class="previous" href="../configurations/"><span class="direction">Previous</span><span class="title">Configurations</span></a><a class="next" href="../csfs/"><span class="direction">Next</span><span class="title">CSFs</span></a></footer></article></body></html>
