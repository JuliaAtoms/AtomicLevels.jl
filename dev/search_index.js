var documenterSearchIndex = {"docs":
[{"location":"csfs/","page":"CSFs","title":"CSFs","text":"DocTestSetup = :(using AtomicLevels)","category":"page"},{"location":"csfs/#man-csfs","page":"CSFs","title":"Atomic configuration state functions (CSFs)","text":"","category":"section"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"AtomicLevels also provides types to represent symmetry-adapted atomic states, commonly referred to as configuration state functions (CSFs). These are linear combinations of Slater determinants arising from a particular configuration, that are also eigenstates of angular momentum operators.","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"info: Angular momentum operators\nWith relativistic orbitals and jj-coupling, angular momentum operators refer to the J^2 and J_z operators.However, when working with non-relativistic orbitals and in LS-coupling, they refer to both the orbital angular momentum operators (L^2, L_z) and the spin angular momentum operators (S^2, S_z). In  this case, the orbitals and CSFs are simultaneous eigenstates of both the orbital and spin angular momentum.In the Background section, we use just the total angular momentum operators (J^2, J_z) when illustrating the theoretical background.","category":"page"},{"location":"csfs/#Background","page":"CSFs","title":"Background","text":"","category":"section"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"When constructing a basis for many-particle atomic states, you start from a set of single-particle states (orbitals) and form anti-symmetric many-particle product states (Slater determinants) of the desired number of particles. Superpositions of said determinants can then represent full many-electron wavefunctions. In principle, if the set of one-particle orbitals is complete, the set of all Slater determinants would form a complete many-particle basis.","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"However, even if your orbitals are eigenstates of the angular momentum operators J^2 and J_z, the Slater determinants, formed from these orbitals, in general, are not. As angular momentum symmetry is a useful symmetry to adhere to when working with atomic states, this is where CSFs come in: they form a symmetry adapted many body basis, representing the same many-particle space, but each state is now also an eigenstate of angular momentum. They are related to the underlying Slater determinats via a basis transformation.","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"note: Other symmetries\nYou can also imagine CSFs that are adapted to other symmetries. However, at this time, AtomicLevels only supports CSFs adapted to angular momentum.","category":"page"},{"location":"csfs/#Forming-a-CSF","page":"CSFs","title":"Forming a CSF","text":"","category":"section"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"The philosophy behind CSFs is similar to how you can use the Clebsch–Gordan coefficients C_j_1m_1j_2m_2^J M to couple product states of angular momentum eigenstates ketj_1 m_1 ketj_2 m_2, which themselves in general are not eigenstates of total angular momentum, into angular momentum eigenstates ketj_1 j_2 J M by creating superpositions with appropriate coefficients:","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"ketj_1 j_2 J M = sum_m_1m_2M\nC_j_1m_1j_2m_2^J M\nketj_1 m_1 ketj_2 m_2","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"where the valid J values are j_1 - j_2 leq J leq j_1 + j_2.","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"In the multi-electron case, the states that you multiply together are the atomic orbitals. However, it is complicated by two facts:","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"There are usually more than two electrons.\nIn a multi-electron case, it is perfectly valid to apply the Clebsch–Gordan relation recursively until all electrons have been coupled, but in general you can end up with the same total angular momentum for different states (corresponding to different coupling sequences). So, the angular momentum eigenvalues are no longer sufficient to always uniquely identify a state.\nElectrons are fermionic particles adhering to the Pauli principle.\nThis means that not all direct products of single-particle states are valid (the same single-particle state can not be repeated) or unique (anti-symmetry means that the order in the product does not matter). This, in turn, means that not all the coupled eigenstates predicted by the Clebsch-Gordan relation actually exist and you can not use the Clebsch–Gordan relation directly to determine their coefficients.","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"To work within those constraints, AtomicLevels specifies a coupling scheme. That is, the CSFs contain additional data that allows the states to be identified uniquely.","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"note: Orbital vs subshell\nIn the following the word \"subshell\" is used to refer to the orbitals in a configuration (i.e. a set of states with e.g. the same n and ell quantum numbers). This is because the word \"orbital\" can be ambiguous (referring to either to a subshell or an specific state).","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"CSF type. In AtomicLevels, CSFs are represented with the CSF type. An instance of a CSF only specifies CSFs up to the total angular momentum (i.e. it actually represent a set of states corresponding to the different possible J_z quantum numbers).","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"Forming a CSF is a multi-step process:","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"The starting point for a CSF is a configuration (Configuration), i.e. a list of subshells (the orbitals in the configuration) and their occupations (how many electrons on the subshell). Each configuration corresponds to a set of Slater determinants, generated by considering all the possible combinations of m quantum numbers of the orbitals.\nThe next step is to couple each subshell into an angular momentum eigenstate (e.g. to form a single angular momentum eigenstate out of the 3 electrons on a 3d_52 orbital/subshell). As the single particle spaces for the subshells are disjoint, the space of many-particle determinants can be thought of as a product space of subshells determinant spaces.\nDue to the fermionic nature of the electrons, even determining the valid J values for the subshells is non-trivial. Also, if you go to high enough angular momenta of the orbital and high enough particle number, the angular momentum eigenvalues are no longer sufficient to uniquely identify the subshell terms. So the CSF type stores them as instances of IntermediateTerm, instead of simple numbers (see Term symbols for more information).\nOnce the electrons on individual subshells are coupled, we can couple the subshells themselves together. As the orbitals in a subshell are distinct from the ones in other subshells, this can easily be done with just Clebsch–Gordan coefficients.\nIn AtomicLevels, we assume that the coupling is done by starting from the leftmost orbital pair, coupling those subshells together. Then the coupled two subshells are taken and coupled to the next subshells, and so on. In the end, we get a coupling tree that looks something like this:\n(Image: )\nOn the illustration, J_i q_i pairs refer to the subshell couplings (q_i disambiguating the state if J_i is not sufficient for uniqueness), and J_1i refers to the total angular momentum of the first i coupled subshells. The total angular momenta of the last coupling (J_1k) determines the angular momentum of the whole CSF.","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"So, all in all, a CSF is a configuration, together with the numbers J_i, q_i and J_1i uniquely determining the coupling.","category":"page"},{"location":"csfs/#Coupling-schemes","page":"CSFs","title":"Coupling schemes","text":"","category":"section"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"Various coupling schemes exist and AtomicLevels is currently opinionated about it, using the scheme described above. The only generality is that it allows for different coupling schemes depending on whether one works with relativistic or non-relativistic orbitals.","category":"page"},{"location":"csfs/#LS-coupling","page":"CSFs","title":"LS-coupling","text":"","category":"section"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"In LS-coupling, each orbital must be a Orbital, specified by its n and ell quantum numbers. Implicitly, each orbital also has a spin of s = 12.","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"When coupling is performed, the L and S spaces are coupled separately, which is possible because the real and spin spaces are orthogonal. Each subshell then gets an L and S values eigenvalue (together with an additional quantum number to resolve any ambiguity). Similarly, couplings between subshells are also defined by the L and S values separately.","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"The CSF will then be a simultaneous eigenstate of L and S, but does not define a J value. In other words, AtomicLevels currently does not perform LSJ-coupling.","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"The convenience type NonRelativisticCSF is provided to construct CSFs with non-relativistic orbitals in LS-coupling.","category":"page"},{"location":"csfs/#jj-coupling","page":"CSFs","title":"jj-coupling","text":"","category":"section"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"jj-coupling is used for RelativisticOrbitals, where each orbital only has the total angular momentum value J. In this coupling scheme, only the J values coupled. Intermediate terms are the J values (together with disambiguating quantum numbers, like seniority), and the intra-shell couplings are also defined by their J value.","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"The convenience type RelativisticCSF is provided to construct CSFs with relativistic orbitals in jj-coupling.","category":"page"},{"location":"csfs/#Reference","page":"CSFs","title":"Reference","text":"","category":"section"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"CSF\nNonRelativisticCSF\nRelativisticCSF\ncsfs","category":"page"},{"location":"csfs/#AtomicLevels.CSF","page":"CSFs","title":"AtomicLevels.CSF","text":"struct CSF\n\nRepresents a single configuration state function (CSF) adapted to angular momentum symmetries. Depending on the type parameters, it can represent both non-relativistic CSFs in LS-coupling and relativistic CSFs in jj-coupling.\n\nA CSF is defined by the following information:\n\nThe configuration, i.e. an ordered list of subshells together with their occupations.\nA list of intermediate coupling terms (including the seniority quantum number to label states in degenerate subspaces) for each subshell in the configuration.\nA list of coupling terms for the coupling tree. The coupling is assumed to be done by, first, coupling two orbitals together, then coupling that to the next orbital, and so on.\n\nAn instance of a CSF object does not specify the J_z or L_z/S_z quantum number(s).\n\nConstructors\n\nCSF(configuration::Configuration, subshell_terms::Vector, terms::Vector)\n\nConstructs an instance of a CSF from the information provided. The arguments have different requirements depending on whether it is configuration is based on relativistic or non-relativistic orbitals.\n\nIf the configuration is based on Orbitals, subshell_terms must be a list of IntermediateTerms and terms a list of Terms.\nIf it is a configuration of RelativisticOrbitals, both subshell_terms and terms should both be a list of half-integer values.\n\n\n\n\n\n","category":"type"},{"location":"csfs/#AtomicLevels.NonRelativisticCSF","page":"CSFs","title":"AtomicLevels.NonRelativisticCSF","text":"const NonRelativisticCSF = CSF{<:Orbital,Term}\n\n\n\n\n\n","category":"type"},{"location":"csfs/#AtomicLevels.RelativisticCSF","page":"CSFs","title":"AtomicLevels.RelativisticCSF","text":"const RelativisticCSF = CSF{<:RelativisticOrbital,HalfInt}\n\n\n\n\n\n","category":"type"},{"location":"csfs/#AtomicLevels.csfs","page":"CSFs","title":"AtomicLevels.csfs","text":"csfs(::Configuration) -> Vector{CSF}\ncsfs(::Vector{Configuration}) -> Vector{CSF}\n\nGenerate all CSFs corresponding to a particular configuration or a set of configurations.\n\n\n\n\n\n","category":"function"},{"location":"csfs/#Index","page":"CSFs","title":"Index","text":"","category":"section"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"Pages = [\"csfs.md\"]","category":"page"},{"location":"csfs/","page":"CSFs","title":"CSFs","text":"DocTestSetup = nothing","category":"page"},{"location":"configurations/#man-configurations","page":"Configurations","title":"Atomic configurations","text":"","category":"section"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"DocTestSetup = quote\n    using AtomicLevels\nend","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"We define a configuration to be a set of orbitals with their associated occupation (i.e. the number of electron on that orbital). We can represent a particular configuration with an instance of the Configuration type. The orbitals of a configuration can be unsorted (default) or sorted according to the canonical ordering (first by n, then by ell, &c). It is important to allow for arbitrary order, since permutation of the orbitals in a configuration, in general incurs a phase shift of matrix elements, &c.","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"Configuration","category":"page"},{"location":"configurations/#AtomicLevels.Configuration","page":"Configurations","title":"AtomicLevels.Configuration","text":"struct Configuration{<:AbstractOrbital}\n\nRepresents a configuration – a set of orbitals and their associated occupation number.  Furthermore, each orbital can be in one of the following states: :open, :closed or :inactive.\n\nConstructors\n\nConfiguration(orbitals :: Vector{<:AbstractOrbital},\n              occupancy :: Vector{Int},\n              states :: Vector{Symbol}\n              [; sorted=false])\n\nConfiguration(orbitals :: Vector{Tuple{<:AbstractOrbital, Int, Symbol}}\n              [; sorted=false])\n\nIn the first case, the parameters of each orbital have to be passed as separate vectors, and the orbitals and occupancy have to be of the same length. The states vector can be shorter and then the latter orbitals that were not explicitly specified by states are assumed to be :open.\n\nThe second constructor allows you to pass a vector of tuples instead, where each tuple is a triplet (orbital :: AbstractOrbital, occupancy :: Int, state :: Symbol) corresponding to each orbital.\n\nIn all cases, all the orbitals have to be distinct. The orbitals in the configuration will be sorted (if sorted) according to the ordering defined for the particular AbstractOrbital.\n\n\n\n\n\n","category":"type"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"The @c_str and @rc_str string macros can be used to conveniently construct configurations:","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"@c_str\n@rc_str","category":"page"},{"location":"configurations/#AtomicLevels.@c_str","page":"Configurations","title":"AtomicLevels.@c_str","text":"@c_str -> Configuration{Orbital}\n\nConstruct a Configuration, representing a non-relativistic configuration, out of a string. With the added string macro suffix s, the configuration is sorted.\n\nExamples\n\njulia> c\"1s2 2s\"\n1s² 2s\n\njulia> c\"1s² 2s\"\n1s² 2s\n\njulia> c\"1s2.2s\"\n1s² 2s\n\njulia> c\"[Kr] 4d10 5s2 4f2\"\n[Kr]ᶜ 4d¹⁰ 5s² 4f²\n\njulia> c\"[Kr] 4d10 5s2 4f2\"s\n[Kr]ᶜ 4d¹⁰ 4f² 5s²\n\n\n\n\n\n","category":"macro"},{"location":"configurations/#AtomicLevels.@rc_str","page":"Configurations","title":"AtomicLevels.@rc_str","text":"@rc_str -> Configuration{RelativisticOrbital}\n\nConstruct a Configuration representing a relativistic configuration out of a string. With the added string macro suffix s, the configuration is sorted.\n\nExamples\n\njulia> rc\"[Ne] 3s 3p- 3p\"\n[Ne]ᶜ 3s 3p- 3p\n\njulia> rc\"[Ne] 3s 3p-2 3p4\"\n[Ne]ᶜ 3s 3p-² 3p⁴\n\njulia> rc\"[Ne] 3s 3p-² 3p⁴\"\n[Ne]ᶜ 3s 3p-² 3p⁴\n\njulia> rc\"2p- 1s\"s\n1s 2p-\n\n\n\n\n\n","category":"macro"},{"location":"configurations/#Interface","page":"Configurations","title":"Interface","text":"","category":"section"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"For example, it is possible to index into a configuration, including with a range of indices, returning a sub-configuration consisting of only those orbitals. With an integer index, an (orbital, occupancy, state) tuple is returned.","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"julia> config = c\"1s2c 2si 2p3\"\n[He]ᶜ 2sⁱ 2p³\n\njulia> config[2]\n(2s, 1, :inactive)\n\njulia> config[1:2]\n[He]ᶜ 2sⁱ\n\njulia> config[[3,1]]\n[He]ᶜ 2p³","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"The configuration can also be iterated over. Each item is a (orbital, occupancy, state) tuple.","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"julia> for (o, nelec, s) in config\n           @show o, nelec, s\n       end\n(o, nelec, s) = (1s, 2, :closed)\n(o, nelec, s) = (2s, 1, :inactive)\n(o, nelec, s) = (2p, 3, :open)","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"Various other methods exist to manipulate or transform configurations or to query them for information.","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"issimilar\nBase.:(==)(a::Configuration{<:O}, b::Configuration{<:O}) where {O<:AbstractOrbital}\nnum_electrons(::Configuration)\nnum_electrons(::Configuration, ::AtomicLevels.AbstractOrbital)\nBase.delete!\nBase.:(+)\nBase.:(-)\nBase.close\nclose!\nBase.fill\nBase.fill!\nBase.in\nBase.filter\nBase.replace\ncore\npeel\nactive\ninactive\nbound\ncontinuum\nparity(::Configuration)\nnonrelconfiguration\nrelconfigurations\nmultiplicity(::Configuration)","category":"page"},{"location":"configurations/#AtomicLevels.issimilar","page":"Configurations","title":"AtomicLevels.issimilar","text":"issimilar(a::Configuration, b::Configuration)\n\nCompares the electronic configurations a and b, only considering the constituent orbitals and their occupancy, but disregarding their ordering and states (:open, :closed, &c).\n\nExamples\n\njulia> a = c\"1s 2s\"\n1s 2s\n\njulia> b = c\"2si 1s\"\n2sⁱ 1s\n\njulia> issimilar(a, b)\ntrue\n\njulia> a==b\nfalse\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Base.:==-Union{Tuple{O}, Tuple{Configuration{#s1} where #s1<:O,Configuration{#s2} where #s2<:O}} where O<:AbstractOrbital","page":"Configurations","title":"Base.:==","text":"==(a::Configuration, b::Configuration)\n\nTests if configurations a and b are the same, considering orbital occupancy, ordering, and states.\n\nExamples\n\njulia> c\"1s 2s\" == c\"1s 2s\"\ntrue\n\njulia> c\"1s 2s\" == c\"1s 2si\"\nfalse\n\njulia> c\"1s 2s\" == c\"2s 1s\"\nfalse\n\n\n\n\n\n","category":"method"},{"location":"configurations/#AtomicLevels.num_electrons-Tuple{Configuration}","page":"Configurations","title":"AtomicLevels.num_electrons","text":"num_electrons(c::Configuration) -> Int\n\nReturn the number of electrons in the configuration.\n\njulia> num_electrons(c\"1s2\")\n2\n\njulia> num_electrons(rc\"[Kr] 5s2 5p-2 5p2\")\n42\n\n\n\n\n\n","category":"method"},{"location":"configurations/#AtomicLevels.num_electrons-Tuple{Configuration,AbstractOrbital}","page":"Configurations","title":"AtomicLevels.num_electrons","text":"num_electrons(c::Configuration, o::AbstractOrbital) -> Int\n\nReturns the number of electrons on orbital o in configuration c. If o is not part of the configuration, returns 0.\n\njulia> num_electrons(c\"1s 2s2\", o\"2s\")\n2\n\njulia> num_electrons(rc\"[Rn] Qf-5 Pf3\", ro\"Qf-\")\n5\n\njulia> num_electrons(c\"[Ne]\", o\"3s\")\n0\n\n\n\n\n\n","category":"method"},{"location":"configurations/#Base.delete!","page":"Configurations","title":"Base.delete!","text":"delete!(c::Configuration, o::AbstractOrbital)\n\nRemove the entire subshell corresponding to orbital o from configuration c.\n\njulia> delete!(c\"[Ar] 4s2 3d10 4p2\", o\"4s\")\n[Ar]ᶜ 3d¹⁰ 4p²\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Base.:+","page":"Configurations","title":"Base.:+","text":"+(::Configuration, ::Configuration)\n\nAdd two configurations together. If both configuration have an orbital, the number of electrons gets added together, but in this case the status of the orbitals must match.\n\njulia> c\"1s\" + c\"2s\"\n1s 2s\n\njulia> c\"1s\" + c\"1s\"\n1s²\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Base.:-","page":"Configurations","title":"Base.:-","text":"-(configuration::Configuration, orbital::AbstractOrbital[, n=1])\n\nRemove n electrons in the orbital orbital from the configuration configuration. If the orbital had previously been :closed or :inactive, it will now be :open.\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Base.close","page":"Configurations","title":"Base.close","text":"close(c::Configuration)\n\nReturn a corresponding configuration where where all the orbitals are marked :closed.\n\nSee also: close!\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.close!","page":"Configurations","title":"AtomicLevels.close!","text":"close!(c::Configuration)\n\nMarks all the orbitals in configuration c as closed.\n\nSee also: close\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Base.fill","page":"Configurations","title":"Base.fill","text":"fill(c::Configuration)\n\nReturns a corresponding configuration where the orbitals are completely filled (as determined by degeneracy).\n\nSee also: fill!\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Base.fill!","page":"Configurations","title":"Base.fill!","text":"fill!(c::Configuration)\n\nSets all the occupancies in configuration c to maximum, as determined by the degeneracy function.\n\nSee also: fill\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Base.in","page":"Configurations","title":"Base.in","text":"in(o::AbstractOrbital, c::Configuration) -> Bool\n\nChecks if orbital o is part of configuration c.\n\njulia> in(o\"2s\", c\"1s2 2s2\")\ntrue\n\njulia> o\"2p\" ∈ c\"1s2 2s2\"\nfalse\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Base.filter","page":"Configurations","title":"Base.filter","text":"filter(f, c::Configuration) -> Configuration\n\nFilter out the orbitals from configuration c for which the predicate f returns false. The predicate f needs to take three arguments: orbital, occupancy and state.\n\njulia> filter((o,occ,s) -> o.ℓ == 1, c\"[Kr]\")\n2p⁶ᶜ 3p⁶ᶜ 4p⁶ᶜ\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Base.replace","page":"Configurations","title":"Base.replace","text":"replace(conf, a => b[; append=false])\n\nSubstitute one electron in orbital a of conf by one electron in orbital b. If conf is unsorted the substitution is performed in-place, unless append, in which case the new orbital is appended instead.\n\nExamples\n\njulia> replace(c\"1s2 2s\", o\"1s\" => o\"2p\")\n1s 2p 2s\n\njulia> replace(c\"1s2 2s\", o\"1s\" => o\"2p\", append=true)\n1s 2s 2p\n\njulia> replace(c\"1s2 2s\"s, o\"1s\" => o\"2p\")\n1s 2s 2p\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.core","page":"Configurations","title":"AtomicLevels.core","text":"core(::Configuration) -> Configuration\n\nReturn the core configuration (i.e. the sub-configuration of all the orbitals that are marked :closed).\n\njulia> core(c\"1s2c 2s2c 2p6c 3s2\")\n[Ne]ᶜ\n\njulia> core(c\"1s2 2s2\")\n∅\n\njulia> core(c\"1s2 2s2c 2p6c\")\n2s²ᶜ 2p⁶ᶜ\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.peel","page":"Configurations","title":"AtomicLevels.peel","text":"peel(::Configuration) -> Configuration\n\nReturn the non-core part of the configuration (i.e. orbitals not marked :closed).\n\njulia> peel(c\"1s2c 2s2c 2p3\")\n2p³\n\njulia> peel(c\"[Ne] 3s 3p3\")\n3s 3p³\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.active","page":"Configurations","title":"AtomicLevels.active","text":"active(::Configuration) -> Configuration\n\nReturn the part of the configuration marked :open.\n\njulia> active(c\"1s2c 2s2i 2p3i 3s2\")\n3s²\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.inactive","page":"Configurations","title":"AtomicLevels.inactive","text":"inactive(::Configuration) -> Configuration\n\nReturn the part of the configuration marked :inactive.\n\njulia> inactive(c\"1s2c 2s2i 2p3i 3s2\")\n2s²ⁱ 2p³ⁱ\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.bound","page":"Configurations","title":"AtomicLevels.bound","text":"bound(::Configuration) -> Configuration\n\nReturn the bound part of the configuration (see also isbound).\n\njulia> bound(c\"1s2 2s2 2p4 Ks2 Kp1\")\n1s² 2s² 2p⁴\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.continuum","page":"Configurations","title":"AtomicLevels.continuum","text":"continuum(::Configuration) -> Configuration\n\nReturn the non-bound (continuum) part of the configuration (see also isbound).\n\njulia> continuum(c\"1s2 2s2 2p4 Ks2 Kp1\")\nKs² Kp\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.parity-Tuple{Configuration}","page":"Configurations","title":"AtomicLevels.parity","text":"parity(::Configuration) -> Parity\n\nReturn the parity of the configuration.\n\njulia> parity(c\"1s 2p\")\nodd\n\njulia> parity(c\"1s 2p2\")\neven\n\nSee also: Parity\n\n\n\n\n\n","category":"method"},{"location":"configurations/#AtomicLevels.nonrelconfiguration","page":"Configurations","title":"AtomicLevels.nonrelconfiguration","text":"nonrelconfiguration(c::Configuration{<:RelativisticOrbital}) -> Configuration{<:Orbital}\n\nReduces a relativistic configuration down to the corresponding non-relativistic configuration.\n\njulia> c = rc\"1s2 2p-2 2s 2p2 3s2 3p-\"s\n1s² 2s 2p-² 2p² 3s² 3p-\n\njulia> nonrelconfiguration(c)\n1s² 2s 2p⁴ 3s² 3p\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.relconfigurations","page":"Configurations","title":"AtomicLevels.relconfigurations","text":"relconfigurations(c::Configuration{<:Orbital}) -> Vector{<:Configuration{<:RelativisticOrbital}}\n\nGenerate all relativistic configurations from the non-relativistic configuration c, by applying rconfigurations_from_orbital to each subshell and combining the results.\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.multiplicity-Tuple{Configuration}","page":"Configurations","title":"AtomicLevels.multiplicity","text":"multiplicity(::Configuration)\n\nCalculates the number of Slater determinants corresponding to the configuration.\n\n\n\n\n\n","category":"method"},{"location":"configurations/#Generating-configuration-lists","page":"Configurations","title":"Generating configuration lists","text":"","category":"section"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"The ⊗ operator can be used to easily generate lists of configurations from existing pieces. E.g. to create all the valence configurations on top of an closed core, you only need to write","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"julia> c\"[Ne]\" ⊗ [c\"3s2\", c\"3s 3p\", c\"3p2\"]\n3-element Array{Configuration{Orbital{Int64}},1}:\n [Ne]ᶜ 3s²\n [Ne]ᶜ 3s 3p\n [Ne]ᶜ 3p²","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"That can be combined with the @rcs_str string macro to easily generate all possible relativistic configurations from a non-relativistic definition:","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"julia> rc\"[Ne] 3s2\" ⊗ rcs\"3p2\"\n3-element Array{Configuration{RelativisticOrbital{Int64}},1}:\n [Ne]ᶜ 3s² 3p-²\n [Ne]ᶜ 3s² 3p- 3p\n [Ne]ᶜ 3s² 3p²","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"⊗\n@rcs_str","category":"page"},{"location":"configurations/#AtomicLevels.:⊗","page":"Configurations","title":"AtomicLevels.:⊗","text":"⊗(::Union{Configuration, Vector{Configuration}}, ::Union{Configuration, Vector{Configuration}})\n\nGiven two collections of Configurations, it creates an array of Configurations with all possible juxtapositions of configurations from each collection.\n\nExamples\n\njulia> c\"1s\" ⊗ [c\"2s2\", c\"2s 2p\"]\n2-element Array{Configuration{Orbital{Int64}},1}:\n 1s 2s²\n 1s 2s 2p\n\njulia> [rc\"1s\", rc\"2s\"] ⊗ [rc\"2p-\", rc\"2p\"]\n4-element Array{Configuration{RelativisticOrbital{Int64}},1}:\n 1s 2p-\n 1s 2p\n 2s 2p-\n 2s 2p\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.@rcs_str","page":"Configurations","title":"AtomicLevels.@rcs_str","text":"@rcs_str -> Vector{Configuration{RelativisticOrbital}}\n\nConstruct a Vector of all Configurations corresponding to the non-relativistic nℓ orbital with the given occupancy from the input string.\n\nThe string is assumed to have the following syntax: $(n)$(ℓ)$(occupancy), where n and occupancy are integers, and ℓ is in spectroscopic notation.\n\nExamples\n\njulia> rcs\"3p2\"\n3-element Array{Configuration{#s21} where #s21<:RelativisticOrbital,1}:\n 3p-²\n 3p- 3p\n 3p²\n\n\n\n\n\n","category":"macro"},{"location":"configurations/#Spin-configurations","page":"Configurations","title":"Spin configurations","text":"","category":"section"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"SpinConfiguration\nspin_configurations\nsubstitutions\n@sc_str\n@rsc_str\n@scs_str","category":"page"},{"location":"configurations/#AtomicLevels.SpinConfiguration","page":"Configurations","title":"AtomicLevels.SpinConfiguration","text":"SpinConfiguration\n\nSpecialization of Configuration for configurations consisting of SpinOrbitals.\n\n\n\n\n\n","category":"type"},{"location":"configurations/#AtomicLevels.spin_configurations","page":"Configurations","title":"AtomicLevels.spin_configurations","text":"spin_configurations(configuration)\n\nGenerate all possible configurations of spin-orbitals from configuration, i.e. all permissible values for the quantum numbers n, ℓ, mℓ, ms for each electron. Example:\n\njulia> spin_configurations(c\"1s2\")\n1-element Array{Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}},1}:\n 1s₀α 1s₀β\n\njulia> spin_configurations(c\"1s2\"s)\n1-element Array{Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}},1}:\n 1s₀α 1s₀β\n\njulia> spin_configurations(c\"1s ks\")\n4-element Array{Configuration{SpinOrbital{#s16,Tuple{Int64,HalfIntegers.Half{Int64}}} where #s16<:Orbital},1}:\n 1s₀α ks₀α\n 1s₀β ks₀α\n 1s₀α ks₀β\n 1s₀β ks₀β\n\n\n\n\n\nspin_configurations(configurations)\n\nFor each configuration in configurations, generate all possible configurations of spin-orbitals.\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.substitutions","page":"Configurations","title":"AtomicLevels.substitutions","text":"substitutions(src::SpinConfiguration, dst::SpinConfiguration)\n\nFind all orbital substitutions going from spin-configuration src to configuration dst.\n\n\n\n\n\n","category":"function"},{"location":"configurations/#AtomicLevels.@sc_str","page":"Configurations","title":"AtomicLevels.@sc_str","text":"@sc_str -> SpinConfiguration{<:SpinOrbital{<:Orbital}}\n\nA string macro to construct a non-relativistic SpinConfiguration.\n\nExamples\n\njulia> sc\"1s₀α 2p₋₁β\"\n1s₀α 2p₋₁β\n\njulia> sc\"ks(0,-1/2) l[4](-3,1/2)\"\nks₀β lg₋₃α\n\n\n\n\n\n","category":"macro"},{"location":"configurations/#AtomicLevels.@rsc_str","page":"Configurations","title":"AtomicLevels.@rsc_str","text":"@rsc_str -> SpinConfiguration{<:SpinOrbital{<:RelativisticOrbital}}\n\nA string macro to construct a relativistic SpinConfiguration.\n\nExamples\n\njulia> rsc\"1s(1/2) 2p(-1/2)\"\n1s(1/2) 2p(-1/2)\n\njulia> rsc\"ks(-1/2) l[4]-(-5/2)\"\nks(-1/2) lg-(-5/2)\n\n\n\n\n\n","category":"macro"},{"location":"configurations/#AtomicLevels.@scs_str","page":"Configurations","title":"AtomicLevels.@scs_str","text":"@scs_str -> Vector{<:SpinConfiguration}\n\nGenerate all possible spin-configurations out of a string. With the added string macro suffix s, the configuration is sorted.\n\nExamples\n\njulia> scs\"1s2 2p2\"\n15-element Array{Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}},1}:\n 1s₀α 1s₀β 2p₋₁α 2p₋₁β\n 1s₀α 1s₀β 2p₋₁α 2p₀α\n 1s₀α 1s₀β 2p₋₁α 2p₀β\n 1s₀α 1s₀β 2p₋₁α 2p₁α\n 1s₀α 1s₀β 2p₋₁α 2p₁β\n 1s₀α 1s₀β 2p₋₁β 2p₀α\n 1s₀α 1s₀β 2p₋₁β 2p₀β\n 1s₀α 1s₀β 2p₋₁β 2p₁α\n 1s₀α 1s₀β 2p₋₁β 2p₁β\n 1s₀α 1s₀β 2p₀α 2p₀β\n 1s₀α 1s₀β 2p₀α 2p₁α\n 1s₀α 1s₀β 2p₀α 2p₁β\n 1s₀α 1s₀β 2p₀β 2p₁α\n 1s₀α 1s₀β 2p₀β 2p₁β\n 1s₀α 1s₀β 2p₁α 2p₁β\n\n\n\n\n\n","category":"macro"},{"location":"configurations/#Excited-configurations","page":"Configurations","title":"Excited configurations","text":"","category":"section"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"AtomicLevels.jl provides an easy interface for generating lists of configurations which are the result of exciting one or more orbitals of a reference set to a set of substitution orbitals. This is done with excited_configurations, which provides various parameters for controlling which excitations are generated. A very simple example could be","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"julia> excited_configurations(c\"1s2\", os\"2[s-p]\"...)\n4-element Array{Configuration{Orbital{Int64}},1}:\n 1s²\n 1s 2s\n 2s²\n 2p²","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"which as we see contains all configurations generated by at most exciting two orbitals 1s² and keeping the overall parity. By lifting these restrictions, more configurations can be generated:","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"julia> excited_configurations(c\"1s2 2s\", os\"3[s-p]\"...,\n                              keep_parity=false, max_excitations=2)\n14-element Array{Configuration{Orbital{Int64}},1}:\n 1s² 2s\n 1s 2s²\n 1s 2s 3s\n 1s 2s 3p\n 1s² 3s\n 1s² 3p\n 2s² 3s\n 2s² 3p\n 2s 3s²\n 2s 3s 3p\n 1s 3s²\n 1s 3s 3p\n 2s 3p²\n 1s 3p²\n\njulia> excited_configurations(c\"1s2 2s\", os\"3[s-p]\"...,\n                              keep_parity=false, max_excitations=3)\n17-element Array{Configuration{Orbital{Int64}},1}:\n 1s² 2s\n 1s 2s²\n 1s 2s 3s\n 1s 2s 3p\n 1s² 3s\n 1s² 3p\n 2s² 3s\n 2s² 3p\n 2s 3s²\n 2s 3s 3p\n 1s 3s²\n 1s 3s 3p\n 2s 3p²\n 1s 3p²\n 3s² 3p\n 3s 3p²\n 3p³","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"Since configurations by default are unsorted, when exciting from SpinConfigurations, the substitutions are performed in-place:","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"julia> excited_configurations(first(scs\"1s2\"), sos\"2[s-p]\"...)\n21-element Array{Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}},1}:\n 1s₀α 1s₀β\n 2s₀α 1s₀β\n 2s₀β 1s₀β\n 1s₀α 2s₀α\n 1s₀α 2s₀β\n 2s₀α 2s₀β\n 2p₋₁α 2p₋₁β\n 2p₋₁α 2p₀α\n 2p₋₁α 2p₀β\n 2p₋₁α 2p₁α\n ⋮\n 2p₋₁β 2p₀β\n 2p₋₁β 2p₁α\n 2p₋₁β 2p₁β\n 2p₀α 2p₀β\n 2p₀α 2p₁α\n 2p₀α 2p₁β\n 2p₀β 2p₁α\n 2p₀β 2p₁β\n 2p₁α 2p₁β","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"excited_configurations","category":"page"},{"location":"configurations/#AtomicLevels.excited_configurations","page":"Configurations","title":"AtomicLevels.excited_configurations","text":"excited_configurations([fun::Function, ] cfg::Configuration,\n                       orbitals::AbstractOrbital...\n                       [; min_excitations=0, max_excitations=:doubles,\n                        min_occupancy=[0, 0, ...], max_occupancy=[..., g_i, ...],\n                        keep_parity=true])\n\nGenerate all excitations from the reference set cfg by substituting at least min_excitations and at most max_excitations of the substitution orbitals. min_occupancy specifies the minimum occupation number for each of the source orbitals (default 0) and equivalently max_occupancy specifies the maximum occupation number (default is the degeneracy for each orbital). keep_parity controls whether the excited configuration has to have the same parity as cfg. Finally, fun allows modification of the substitution orbitals depending on the source orbitals, which is useful for generating ionized configurations. If fun returns nothing, that particular substitution will be rejected.\n\nExamples\n\njulia> excited_configurations(c\"1s2\", o\"2s\", o\"2p\")\n4-element Array{Configuration{Orbital{Int64}},1}:\n 1s²\n 1s 2s\n 2s²\n 2p²\n\njulia> excited_configurations(c\"1s2 2p\", o\"2p\")\n2-element Array{Configuration{Orbital{Int64}},1}:\n 1s² 2p\n 2p³\n\njulia> excited_configurations(c\"1s2 2p\", o\"2p\", max_occupancy=[2,2])\n1-element Array{Configuration{Orbital{Int64}},1}:\n 1s² 2p\n\njulia> excited_configurations(first(scs\"1s2\"), sos\"k[s]\"...) do dst,src\n           if isbound(src)\n               # Generate label that indicates src orbital,\n               # i.e. the resultant hole\n               SpinOrbital(Orbital(Symbol(\"[$(src)]\"), dst.orb.ℓ), dst.m)\n           else\n               dst\n           end\n       end\n9-element Array{Configuration{SpinOrbital{#s16,Tuple{Int64,HalfIntegers.Half{Int64}}} where #s16<:Orbital},1}:\n 1s₀α 1s₀β\n [1s₀α]s₀α 1s₀β\n [1s₀α]s₀β 1s₀β\n 1s₀α [1s₀β]s₀α\n 1s₀α [1s₀β]s₀β\n [1s₀α]s₀α [1s₀β]s₀α\n [1s₀α]s₀β [1s₀β]s₀α\n [1s₀α]s₀α [1s₀β]s₀β\n [1s₀α]s₀β [1s₀β]s₀β\n\njulia> excited_configurations((a,b) -> a.m == b.m ? a : nothing,\n                              spin_configurations(c\"1s\"), sos\"k[s-d]\"..., keep_parity=false)\n8-element Array{Configuration{SpinOrbital{#s16,Tuple{Int64,HalfIntegers.Half{Int64}}} where #s16<:Orbital},1}:\n 1s₀α\n ks₀α\n kp₀α\n kd₀α\n 1s₀β\n ks₀β\n kp₀β\n kd₀β\n\n\n\n\n\n","category":"function"},{"location":"configurations/#Index","page":"Configurations","title":"Index","text":"","category":"section"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"Pages = [\"configurations.md\"]","category":"page"},{"location":"configurations/","page":"Configurations","title":"Configurations","text":"DocTestSetup = nothing","category":"page"},{"location":"orbitals/#man-orbitals","page":"Orbitals","title":"Atomic orbitals","text":"","category":"section"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"DocTestSetup = quote\n    using AtomicLevels\nend","category":"page"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"Atomic orbitals, i.e. single particle states with well-defined orbital or total angular momentum, are usually the basic building blocks of atomic states. AtomicLevels provides various types and methods to conveniently label the orbitals.","category":"page"},{"location":"orbitals/#Orbital-types","page":"Orbitals","title":"Orbital types","text":"","category":"section"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"AtomicLevels provides two basic types for labelling atomic orbitals: Orbital and RelativisticOrbital. Stricly speaking, these types do not label orbitals, but groups of orbitals with the same angular symmetry and radial behaviour (i.e. a subshell).","category":"page"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"All orbitals are subtypes of AbstractOrbital. Types and methods that work on generic orbitals can dispatch on that.","category":"page"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"Orbital\nRelativisticOrbital\nAbstractOrbital","category":"page"},{"location":"orbitals/#AtomicLevels.Orbital","page":"Orbitals","title":"AtomicLevels.Orbital","text":"struct Orbital{N <: AtomicLevels.MQ} <: AbstractOrbital\n\nLabel for an atomic orbital with a principal quantum number n::N and orbital angular momentum ℓ.\n\nThe type parameter N has to be such that it can represent a proper principal quantum number (i.e. a subtype of AtomicLevels.MQ).\n\nProperties\n\nThe following properties are part of the public API:\n\n.n :: N – principal quantum number n\n.ℓ :: Int – the orbital angular momentum ell\n\nConstructors\n\nOrbital(n::Int, ℓ::Int)\nOrbital(n::Symbol, ℓ::Int)\n\nConstruct an orbital label with principal quantum number n and orbital angular momentum ℓ. If the principal quantum number n is an integer, it has to positive and the angular momentum must satisfy 0 <= ℓ < n.\n\njulia> Orbital(1, 0)\n1s\n\njulia> Orbital(:K, 2)\nKd\n\n\n\n\n\n","category":"type"},{"location":"orbitals/#AtomicLevels.RelativisticOrbital","page":"Orbitals","title":"AtomicLevels.RelativisticOrbital","text":"struct RelativisticOrbital{N <: AtomicLevels.MQ} <: AbstractOrbital\n\nLabel for an atomic orbital with a principal quantum number n::N and well-defined total angular momentum j. The angular component of the orbital is labelled by the (ell j) pair, conventionally written as ell_j (e.g. p_32).\n\nThe ell and j can not be arbitrary, but must satisfy j = ell pm 12. Internally, the kappa quantum number, which is a unique integer corresponding to every physical (ell j) pair, is used to label each allowed pair. When j = ell pm 12, the corresponding kappa = mp(j + 12).\n\nWhen printing and parsing RelativisticOrbitals, the notation nℓ and nℓ- is used (e.g. 2p and 2p-), corresponding to the orbitals with j = ell + 12 and j = ell - 12, respectively.\n\nThe type parameter N has to be such that it can represent a proper principal quantum number (i.e. a subtype of AtomicLevels.MQ).\n\nProperties\n\nThe following properties are part of the public API:\n\n.n :: N – principal quantum number n\n.κ :: Int – kappa quantum number\n.ℓ :: Int – the orbital angular momentum label ell\n.j :: HalfInteger – total angular momentum j\n\njulia> orb = ro\"5g-\"\n5g-\n\njulia> orb.n\n5\n\njulia> orb.j\n7/2\n\njulia> orb.ℓ\n4\n\nConstructors\n\nRelativisticOrbital(n::Integer, κ::Integer)\nRelativisticOrbital(n::Symbol, κ::Integer)\nRelativisticOrbital(n, ℓ::Integer, j::Real)\n\nConstruct an orbital label with the quantum numbers n and κ. If the principal quantum number n is an integer, it has to positive and the orbital angular momentum must satisfy 0 <= ℓ < n. Instead of κ, valid ℓ and j values can also be specified instead.\n\njulia> RelativisticOrbital(1, 0, 1//2)\n1s\n\njulia> RelativisticOrbital(2, -1)\n2s\n\njulia> RelativisticOrbital(:K, 2, 3//2)\nKd-\n\n\n\n\n\n","category":"type"},{"location":"orbitals/#AtomicLevels.AbstractOrbital","page":"Orbitals","title":"AtomicLevels.AbstractOrbital","text":"abstract type AbstractOrbital\n\nAbstract supertype of all orbital types.\n\n\n\n\n\n","category":"type"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"The SpinOrbital type can be used to fully qualify all the quantum numbers (that is, also m_ell and m_s) of an Orbital. It represent a since, distinct orbital.","category":"page"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"SpinOrbital","category":"page"},{"location":"orbitals/#AtomicLevels.SpinOrbital","page":"Orbitals","title":"AtomicLevels.SpinOrbital","text":"struct SpinOrbital{O<:Orbital} <: AbstractOrbital\n\nSpin orbitals are fully characterized orbitals, i.e. the projections of all angular momenta are specified.\n\n\n\n\n\n","category":"type"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"The string macros @o_str and @ro_str can be used to conveniently construct orbitals, while @os_str, @sos_str, @ros_str, and @rsos_str can be used to construct whole lists of them very easily.","category":"page"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"@o_str\n@so_str\n@ro_str\n@rso_str\n@os_str\n@sos_str\n@ros_str\n@rsos_str","category":"page"},{"location":"orbitals/#AtomicLevels.@o_str","page":"Orbitals","title":"AtomicLevels.@o_str","text":"@o_str -> Orbital\n\nA string macro to construct an Orbital from the canonical string representation.\n\njulia> o\"1s\"\n1s\n\njulia> o\"Fd\"\nFd\n\n\n\n\n\n","category":"macro"},{"location":"orbitals/#AtomicLevels.@so_str","page":"Orbitals","title":"AtomicLevels.@so_str","text":"@so_str -> SpinOrbital{<:Orbital}\n\nString macro to quickly construct a non-relativistic spin-orbital; it is similar to @o_str, with the added specification of the magnetic quantum numbers m_ℓ and m_s.\n\nExamples\n\njulia> so\"1s(0,α)\"\n1s₀α\n\njulia> so\"kd(2,β)\"\nkd₂β\n\njulia> so\"2p(1,0.5)\"\n2p₁α\n\njulia> so\"2p(1,-1/2)\"\n2p₁β\n\n\n\n\n\n","category":"macro"},{"location":"orbitals/#AtomicLevels.@ro_str","page":"Orbitals","title":"AtomicLevels.@ro_str","text":"@ro_str -> RelativisticOrbital\n\nA string macro to construct an RelativisticOrbital from the canonical string representation.\n\njulia> ro\"1s\"\n1s\n\njulia> ro\"2p-\"\n2p-\n\njulia> ro\"Kf-\"\nKf-\n\n\n\n\n\n","category":"macro"},{"location":"orbitals/#AtomicLevels.@rso_str","page":"Orbitals","title":"AtomicLevels.@rso_str","text":"@rso_str -> SpinOrbital{<:RelativisticOrbital}\n\nString macro to quickly construct a relativistic spin-orbital; it is similar to @o_str, with the added specification of the magnetic quantum number m_j.\n\nExamples\n\njulia> rso\"2p-(1/2)\"\n2p-(1/2)\n\njulia> rso\"2p(-3/2)\"\n2p(-3/2)\n\njulia> rso\"3d(2.5)\"\n3d(5/2)\n\n\n\n\n\n","category":"macro"},{"location":"orbitals/#AtomicLevels.@os_str","page":"Orbitals","title":"AtomicLevels.@os_str","text":"@os_str -> Vector{Orbital}\n\nCan be used to easily construct a list of Orbitals.\n\nExamples\n\njulia> os\"5[d] 6[s-p] k[7-10]\"\n7-element Array{Orbital,1}:\n 5d\n 6s\n 6p\n kk\n kl\n km\n kn\n\n\n\n\n\n","category":"macro"},{"location":"orbitals/#AtomicLevels.@sos_str","page":"Orbitals","title":"AtomicLevels.@sos_str","text":"@sos_str -> Vector{<:SpinOrbital{<:Orbital}}\n\nCan be used to easily construct a list of SpinOrbitals.\n\nExamples\n\njulia> sos\"3[s-p]\"\n8-element Array{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}},1}:\n 3s₀α\n 3s₀β\n 3p₋₁α\n 3p₋₁β\n 3p₀α\n 3p₀β\n 3p₁α\n 3p₁β\n\n\n\n\n\n","category":"macro"},{"location":"orbitals/#AtomicLevels.@ros_str","page":"Orbitals","title":"AtomicLevels.@ros_str","text":"@ros_str -> Vector{RelativisticOrbital}\n\nCan be used to easily construct a list of RelativisticOrbitals.\n\nExamples\n\njulia> ros\"2[s-p] 3[p] k[0-d]\"\n10-element Array{RelativisticOrbital,1}:\n 2s\n 2p-\n 2p\n 3p-\n 3p\n ks\n kp-\n kp\n kd-\n kd\n\n\n\n\n\n","category":"macro"},{"location":"orbitals/#AtomicLevels.@rsos_str","page":"Orbitals","title":"AtomicLevels.@rsos_str","text":"@rsos_str -> Vector{<:SpinOrbital{<:RelativisticOrbital}}\n\nCan be used to easily construct a list of SpinOrbitals.\n\nExamples\n\njulia> rsos\"3[s-p]\"\n8-element Array{SpinOrbital{RelativisticOrbital{Int64},Tuple{HalfIntegers.Half{Int64}}},1}:\n 3s(-1/2)\n 3s(1/2)\n 3p-(-1/2)\n 3p-(1/2)\n 3p(-3/2)\n 3p(-1/2)\n 3p(1/2)\n 3p(3/2)\n\n\n\n\n\n","category":"macro"},{"location":"orbitals/#Methods","page":"Orbitals","title":"Methods","text":"","category":"section"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"isless\ndegeneracy\nparity(::Orbital)\nsymmetry\nisbound\nangular_momenta\nangular_momentum_ranges\nspin_orbitals\nnonrelorbital","category":"page"},{"location":"orbitals/#Base.isless","page":"Orbitals","title":"Base.isless","text":"isless(a::Orbital, b::Orbital)\n\nCompares the orbitals a and b to decide which one comes before the other in a configuration.\n\nExamples\n\njulia> o\"1s\" < o\"2s\"\ntrue\n\njulia> o\"1s\" < o\"2p\"\ntrue\n\njulia> o\"ks\" < o\"2p\"\nfalse\n\n\n\n\n\n","category":"function"},{"location":"orbitals/#AtomicLevels.degeneracy","page":"Orbitals","title":"AtomicLevels.degeneracy","text":"degeneracy(orbital::Orbital)\n\nReturns the degeneracy of orbital which is 2(2ℓ+1)\n\nExamples\n\njulia> degeneracy(o\"1s\")\n2\n\njulia> degeneracy(o\"2p\")\n6\n\n\n\n\n\n","category":"function"},{"location":"orbitals/#AtomicLevels.parity-Tuple{Orbital}","page":"Orbitals","title":"AtomicLevels.parity","text":"parity(orbital::Orbital)\n\nReturns the parity of orbital, defined as (-1)^ℓ.\n\nExamples\n\njulia> parity(o\"1s\")\neven\n\njulia> parity(o\"2p\")\nodd\n\n\n\n\n\n","category":"method"},{"location":"orbitals/#AtomicLevels.symmetry","page":"Orbitals","title":"AtomicLevels.symmetry","text":"symmetry(orbital::Orbital)\n\nReturns the symmetry for orbital which is simply ℓ.\n\n\n\n\n\n","category":"function"},{"location":"orbitals/#AtomicLevels.isbound","page":"Orbitals","title":"AtomicLevels.isbound","text":"isbound(::Orbital)\n\nReturns true is the main quantum number is an integer, false otherwise.\n\njulia> isbound(o\"1s\")\ntrue\n\njulia> isbound(o\"ks\")\nfalse\n\n\n\n\n\n","category":"function"},{"location":"orbitals/#AtomicLevels.angular_momenta","page":"Orbitals","title":"AtomicLevels.angular_momenta","text":"angular_momenta(orbital)\n\nReturns the angular momentum quantum numbers of orbital.\n\nExamples\n\njulia> angular_momenta(o\"2s\")\n(0, 1/2)\n\njulia> angular_momenta(o\"3d\")\n(2, 1/2)\n\n\n\n\n\nangular_momenta(orbital)\n\nReturns the angular momentum quantum numbers of orbital.\n\nExamples\n\njulia> angular_momenta(ro\"2p-\")\n(1/2,)\n\njulia> angular_momenta(ro\"3d\")\n(5/2,)\n\n\n\n\n\n","category":"function"},{"location":"orbitals/#AtomicLevels.angular_momentum_ranges","page":"Orbitals","title":"AtomicLevels.angular_momentum_ranges","text":"angular_momentum_ranges(orbital)\n\nReturn the valid ranges within which projections of each of the angular momentum quantum numbers of orbital must fall.\n\nExamples\n\njulia> angular_momentum_ranges(o\"2s\")\n(0:0, -1/2:1/2)\n\njulia> angular_momentum_ranges(o\"4f\")\n(-3:3, -1/2:1/2)\n\n\n\n\n\n","category":"function"},{"location":"orbitals/#AtomicLevels.spin_orbitals","page":"Orbitals","title":"AtomicLevels.spin_orbitals","text":"spin_orbitals(orbital)\n\nGenerate all permissible spin-orbitals for a given orbital, e.g. 2p -> 2p ⊗ mℓ = {-1,0,1} ⊗ ms = {α,β}\n\nExamples\n\njulia> spin_orbitals(o\"2p\")\n6-element Array{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}},1}:\n 2p₋₁α\n 2p₋₁β\n 2p₀α\n 2p₀β\n 2p₁α\n 2p₁β\n\njulia> spin_orbitals(ro\"2p-\")\n2-element Array{SpinOrbital{RelativisticOrbital{Int64},Tuple{HalfIntegers.Half{Int64}}},1}:\n 2p-(-1/2)\n 2p-(1/2)\n\njulia> spin_orbitals(ro\"2p\")\n4-element Array{SpinOrbital{RelativisticOrbital{Int64},Tuple{HalfIntegers.Half{Int64}}},1}:\n 2p(-3/2)\n 2p(-1/2)\n 2p(1/2)\n 2p(3/2)\n\n\n\n\n\n","category":"function"},{"location":"orbitals/#AtomicLevels.nonrelorbital","page":"Orbitals","title":"AtomicLevels.nonrelorbital","text":"nonrelorbital(o)\n\nReturn the non-relativistic orbital corresponding to o.\n\nExamples\n\njulia> nonrelorbital(o\"2p\")\n2p\n\njulia> nonrelorbital(ro\"2p-\")\n2p\n\n\n\n\n\n","category":"function"},{"location":"orbitals/#Index","page":"Orbitals","title":"Index","text":"","category":"section"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"Pages = [\"orbitals.md\"]","category":"page"},{"location":"orbitals/","page":"Orbitals","title":"Orbitals","text":"DocTestSetup = nothing","category":"page"},{"location":"utilities/#Other-utilities","page":"Other utilities","title":"Other utilities","text":"","category":"section"},{"location":"utilities/","page":"Other utilities","title":"Other utilities","text":"DocTestSetup = :(using AtomicLevels)","category":"page"},{"location":"utilities/#Parity","page":"Other utilities","title":"Parity","text":"","category":"section"},{"location":"utilities/","page":"Other utilities","title":"Other utilities","text":"AtomicLevels defines the Parity type, which is used to represent the parity of atomic states etc.","category":"page"},{"location":"utilities/","page":"Other utilities","title":"Other utilities","text":"Parity\n@p_str","category":"page"},{"location":"utilities/#AtomicLevels.Parity","page":"Other utilities","title":"AtomicLevels.Parity","text":"struct Parity\n\nRepresents the parity of a quantum system, taking two possible values: even or odd.\n\nThe integer values that correspond to even and odd parity are +1 and -1, respectively. Base.convert can be used to convert integers into Parity values.\n\njulia> convert(Parity, 1)\neven\n\njulia> convert(Parity, -1)\nodd\n\n\n\n\n\n","category":"type"},{"location":"utilities/#AtomicLevels.@p_str","page":"Other utilities","title":"AtomicLevels.@p_str","text":"@p_str\n\nA string macro to easily construct Parity values.\n\njulia> p\"even\"\neven\n\njulia> p\"odd\"\nodd\n\n\n\n\n\n","category":"macro"},{"location":"utilities/","page":"Other utilities","title":"Other utilities","text":"The parity values also define an algebra and an ordering:","category":"page"},{"location":"utilities/","page":"Other utilities","title":"Other utilities","text":"julia> p\"odd\" < p\"even\"\ntrue\n\njulia> p\"even\" * p\"odd\"\nodd\n\njulia> (p\"odd\")^3\nodd\n\njulia> -p\"odd\"\neven","category":"page"},{"location":"utilities/","page":"Other utilities","title":"Other utilities","text":"The exported parity function is overloaded for many of the types in AtomicLevels, defining a uniform API to determine the parity of an object.","category":"page"},{"location":"utilities/","page":"Other utilities","title":"Other utilities","text":"parity","category":"page"},{"location":"utilities/#AtomicLevels.parity","page":"Other utilities","title":"AtomicLevels.parity","text":"parity(object) -> Parity\n\nReturns the parity of object.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#JJ-to-LSJ","page":"Other utilities","title":"JJ to LSJ","text":"","category":"section"},{"location":"utilities/","page":"Other utilities","title":"Other utilities","text":"jj2ℓsj","category":"page"},{"location":"utilities/#AtomicLevels.jj2ℓsj","page":"Other utilities","title":"AtomicLevels.jj2ℓsj","text":"jj2ℓsj([T=Float64, ]orbs...)\n\nGenerates the block-diagonal matrix that transforms jj-coupled configurations to lsj-coupled ones.\n\nThe blocks correspond to invariant subspaces, which rotate among themselves to form new linear combinations.\n\nThey are sorted according to n,ℓ and within the blocks, the columns are sorted according to mⱼ,j (increasing) and the rows according to s,ℓ,m (increasing).\n\nE.g. the p-block will have the following structure:\n\n ⟨p;-1,↓|3/2,-3/2⟩  │       ⋅                  ⋅             │       ⋅                ⋅           │       ⋅\n ───────────────────┼────────────────────────────────────────┼────────────────────────────────────┼─────────────────\n      ⋅             │  ⟨p;0,↓|1/2,-1/2⟩   ⟨p;0,↓|3/2,-1/2⟩   │       ⋅                ⋅           │       ⋅\n      ⋅             │  ⟨p;-1,↑|1/2,-1/2⟩  ⟨p;-1,↑|3/2,-1/2⟩  │       ⋅                ⋅           │       ⋅\n ───────────────────┼────────────────────────────────────────┼────────────────────────────────────┼─────────────────\n      ⋅             │       ⋅                  ⋅             │  ⟨p;1,↓|1/2,1/2⟩  ⟨p;1,↓|3/2,1/2⟩  │       ⋅\n      ⋅             │       ⋅                  ⋅             │  ⟨p;0,↑|1/2,1/2⟩  ⟨p;0,↑|3/2,1/2⟩  │       ⋅\n ───────────────────┼────────────────────────────────────────┼────────────────────────────────────┼─────────────────\n      ⋅             │       ⋅                  ⋅             │       ⋅                ⋅           │  ⟨p;1,↑|3/2,3/2⟩\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Angular-momentum-quantum-numbers","page":"Other utilities","title":"Angular momentum quantum numbers","text":"","category":"section"},{"location":"utilities/","page":"Other utilities","title":"Other utilities","text":"str2κ\n@κ_str\nκ2ℓ\nκ2j\nℓj2κ","category":"page"},{"location":"utilities/#AtomicLevels.str2κ","page":"Other utilities","title":"AtomicLevels.str2κ","text":"str2κ(s) -> Int\n\nA function to convert the canonical string representation of a ell_j angular label (i.e. ℓ- or ℓ) into the corresponding kappa quantum number.\n\njulia> str2κ.([\"s\", \"p-\", \"p\"])\n3-element Array{Int64,1}:\n -1\n  1\n -2\n\n\n\n\n\n","category":"function"},{"location":"utilities/#AtomicLevels.@κ_str","page":"Other utilities","title":"AtomicLevels.@κ_str","text":"@κ_str -> Int\n\nA string macro to convert the canonical string representation of a ell_j angular label (i.e. ℓ- or ℓ) into the corresponding kappa quantum number.\n\njulia> κ\"s\", κ\"p-\", κ\"p\"\n(-1, 1, -2)\n\n\n\n\n\n","category":"macro"},{"location":"utilities/#AtomicLevels.κ2ℓ","page":"Other utilities","title":"AtomicLevels.κ2ℓ","text":"κ2ℓ(κ::Integer) -> Integer\n\nCalculate the ℓ quantum number corresponding to the κ quantum number.\n\nNote: κ and ℓ values are always integers.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#AtomicLevels.κ2j","page":"Other utilities","title":"AtomicLevels.κ2j","text":"κ2j(κ::Integer) -> HalfInteger\n\nCalculate the j quantum number corresponding to the κ quantum number.\n\nNote: κ is always an integer, but j will be a half-integer value.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#AtomicLevels.ℓj2κ","page":"Other utilities","title":"AtomicLevels.ℓj2κ","text":"ℓj2κ(ℓ::Integer, j::Real) -> Integer\n\nConverts a valid (ℓ, j) pair to the corresponding κ value.\n\nNote: there is a one-to-one correspondence between valid (ℓ,j) pairs and κ values such that for j = ℓ ± 1/2, κ = ∓(j + 1/2).\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Index","page":"Other utilities","title":"Index","text":"","category":"section"},{"location":"utilities/","page":"Other utilities","title":"Other utilities","text":"Pages = [\"utilities.md\"]","category":"page"},{"location":"utilities/","page":"Other utilities","title":"Other utilities","text":"DocTestSetup = nothing","category":"page"},{"location":"terms/#man-terms","page":"Term symbols","title":"Term symbols","text":"","category":"section"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"DocTestSetup = :(using AtomicLevels)","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"AtomicLevels provides types and methods to work and determine term symbols. The \"Term symbol\" and \"Angular momentum coupling\" Wikipedia articles give a good basic overview of the terminology.","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"For term symbols in LS coupling, AtomicLevels provides the Term type.","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"Term","category":"page"},{"location":"terms/#AtomicLevels.Term","page":"Term symbols","title":"AtomicLevels.Term","text":"struct Term\n\nRepresents a term symbol with specific parity in LS-coupling.\n\nOnly the L, S and parity values of the symbol ^2S+1L_J are specified. To specify a level, the J value would have to be specified separately. The valid J values corresponding to given L and S fall in the following range:\n\nL - S leq J leq L+S\n\nConstructors\n\nTerm(L::Real, S::Real, parity::Union{Parity,Integer})\n\nConstructs a Term object with the given L and S quantum numbers and parity. L and S both have to be convertible to HalfIntegers and parity must be of type Parity or ±1.\n\nSee also: @T_str\n\nProperties\n\nTo access the quantum number values, you can use the .L, .S and .parity properties to access the L, S and parity values (represented with Parity), respectively. E.g.:\n\njulia> t = Term(2, 1//2, p\"odd\")\n²Dᵒ\n\njulia> t.L, t.S, t.parity\n(2, 1/2, odd)\n\n\n\n\n\n","category":"type"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"The Term objects can also be constructed with the @T_str string macro.","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"@T_str\nBase.parse(::Type{Term}, ::AbstractString)","category":"page"},{"location":"terms/#AtomicLevels.@T_str","page":"Term symbols","title":"AtomicLevels.@T_str","text":"@T_str -> Term\n\nConstructs a Term object out of its canonical string representation.\n\njulia> T\"1S\"\n¹S\n\njulia> T\"4Po\"\n⁴Pᵒ\n\njulia> T\"⁴Pᵒ\"\n⁴Pᵒ\n\njulia> T\"2[3/2]o\" # jK coupling, common in noble gases\n²[3/2]ᵒ\n\n\n\n\n\n","category":"macro"},{"location":"terms/#Base.parse-Tuple{Type{Term},AbstractString}","page":"Term symbols","title":"Base.parse","text":"parse(::Type{Term}, ::AbstractString) -> Term\n\nParses a string into a Term object.\n\njulia> parse(Term, \"4Po\")\n⁴Pᵒ\n\njulia> parse(Term, \"⁴Pᵒ\")\n⁴Pᵒ\n\nSee also: @T_str\n\n\n\n\n\n","category":"method"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"The terms function can be used to generate all possible term symbols. In the case of relativistic orbitals, the term symbols are simply the valid J values, represented using the HalfInteger type.","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"terms\ncount_terms\nmultiplicity(t::Term)\nweight(t::Term)","category":"page"},{"location":"terms/#AtomicLevels.terms","page":"Term symbols","title":"AtomicLevels.terms","text":"terms(orb::Orbital, w::Int=one(Int))\n\nReturns a list of valid LS term symbols for the orbital orb with w occupancy.\n\nExamples\n\njulia> terms(o\"3d\", 3)\n8-element Array{Term,1}:\n ²P\n ²D\n ²D\n ²F\n ²G\n ²H\n ⁴P\n ⁴F\n\n\n\n\n\nterms(config)\n\nGenerate all final LS terms for config.\n\nExamples\n\njulia> terms(c\"1s\")\n1-element Array{Term,1}:\n ²S\n\njulia> terms(c\"1s 2p\")\n2-element Array{Term,1}:\n ¹Pᵒ\n ³Pᵒ\n\njulia> terms(c\"[Ne] 3d3\")\n7-element Array{Term,1}:\n ²P\n ²D\n ²F\n ²G\n ²H\n ⁴P\n ⁴F\n\n\n\n\n\nterms(o::RelativisticOrbital, w = 1) -> Vector{HalfInt}\n\nReturns a sorted list of valid J values of w equivalent jj-coupled particles on orbital o (i.e. oʷ).\n\nWhen there are degeneracies (i.e. multiple states with the same J and M quantum numbers), the corresponding J value is repeated in the output array.\n\nExamples\n\njulia> terms(ro\"3d\", 3)\n3-element Array{HalfIntegers.Half{Int64},1}:\n 3/2\n 5/2\n 9/2\n\njulia> terms(ro\"3d-\", 3)\n1-element Array{HalfIntegers.Half{Int64},1}:\n 3/2\n\njulia> terms(ro\"4f\", 4)\n8-element Array{HalfIntegers.Half{Int64},1}:\n 0\n 2\n 2\n 4\n 4\n 5\n 6\n 8\n\n\n\n\n\n","category":"function"},{"location":"terms/#AtomicLevels.count_terms","page":"Term symbols","title":"AtomicLevels.count_terms","text":"count_terms(orbital, occupation, term)\n\nCount how many times term occurs among the valid terms of orbital^occupation.\n\njulia> count_terms(o\"1s\", 2, T\"1S\")\n1\n\njulia> count_terms(ro\"6h\", 4, 8)\n4\n\n\n\n\n\n","category":"function"},{"location":"terms/#AtomicLevels.multiplicity-Tuple{Term}","page":"Term symbols","title":"AtomicLevels.multiplicity","text":"multiplicity(t::Term)\n\nReturns the spin multiplicity of the Term t, i.e. the number of possible values of J for a given value of L and S.\n\nExamples\n\njulia> multiplicity(T\"¹S\")\n1\n\njulia> multiplicity(T\"²S\")\n2\n\njulia> multiplicity(T\"³P\")\n3\n\n\n\n\n\n","category":"method"},{"location":"terms/#AtomicLevels.weight-Tuple{Term}","page":"Term symbols","title":"AtomicLevels.weight","text":"weight(t::Term)\n\nReturns the statistical weight of the Term t, i.e. the number of possible microstates: (2S+1)(2L+1).\n\nExamples\n\njulia> weight(T\"¹S\")\n1\n\njulia> weight(T\"²S\")\n2\n\njulia> weight(T\"³P\")\n9\n\n\n\n\n\n","category":"method"},{"location":"terms/#Term-multiplicity-and-intermediate-terms","page":"Term symbols","title":"Term multiplicity and intermediate terms","text":"","category":"section"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"For subshells starting with d³, a term symbol can occur multiple times, each occurrence corresponding to a different physical state (multiplicity higher than one). This happens when there are distinct ways of coupling the electrons, but they yield the same total angular momentum. E.g. a d³ subshell can be coupled in 8 different ways, two of which are both described by the ²D term symbol:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> terms(o\"3d\", 3)\n8-element Array{Term,1}:\n ²P\n ²D\n ²D\n ²F\n ²G\n ²H\n ⁴P\n ⁴F\n\njulia> count_terms(o\"3d\", 3, T\"2D\")\n2","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"The multiplicity can be even higher if more electrons and higher angular momenta are involved:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> count_terms(o\"4f\", 5, T\"2Do\")\n5","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"To distinguish these subshells, extra quantum numbers must be specified. In AtomicLevels, that can be done with the IntermediateTerm type. This is primarily used when specifying the subshell couplings in CSFs.","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"IntermediateTerm\nintermediate_terms","category":"page"},{"location":"terms/#AtomicLevels.IntermediateTerm","page":"Term symbols","title":"AtomicLevels.IntermediateTerm","text":"struct IntermediateTerm{T,S}\n\nRepresents a term together with its extra disambiguating quantum number(s), labelled by ν.\n\nThe term symbol (::T) can either be a Term (for LS-coupling) or a HalfInteger (for jj-coupling).\n\nThe disambiguating quantum number(s) (::S) can be anything as long as they are sortable (i.e. implementing isless). It is up to the user to pick a scheme that is suitable for their application. See \"Disambiguating quantum numbers\" in the manual for discussion on how it is used in AtomicLevels.\n\nSee also: Term, Seniority\n\nConstructors\n\nIntermediateTerm(term, ν)\n\nConstructs an intermediate term with the term symbol term and disambiguating quantum number(s) ν.\n\nProperties\n\nTo access the term symbol and the disambiguating quantum number(s), you can use the .term :: T and .ν :: S (or .nu :: S) properties, respectively. E.g.:\n\njulia> it = IntermediateTerm(T\"2D\", 2)\n₍₂₎²D\n\njulia> it.term, it.ν\n(²D, 2)\n\njulia> it = IntermediateTerm(5//2, Seniority(2))\n₂5/2\n\njulia> it.term, it.nu\n(5/2, ₂)\n\n\n\n\n\n","category":"type"},{"location":"terms/#AtomicLevels.intermediate_terms","page":"Term symbols","title":"AtomicLevels.intermediate_terms","text":"intermediate_terms(orb::Orbital, w::Int=one(Int))\n\nGenerates all IntermediateTerm for a given non-relativstic orbital orb and occupation w.\n\nExamples\n\njulia> intermediate_terms(o\"2p\", 2)\n3-element Array{IntermediateTerm{Term,Seniority},1}:\n ₀¹S\n ₂¹D\n ₂³P\n\nThe preceding subscript is the seniority number, which indicates at which occupancy a certain term is first seen, cf.\n\njulia> intermediate_terms(o\"3d\", 1)\n1-element Array{IntermediateTerm{Term,Seniority},1}:\n ₁²D\n\njulia> intermediate_terms(o\"3d\", 3)\n8-element Array{IntermediateTerm{Term,Seniority},1}:\n ₁²D\n ₃²P\n ₃²D\n ₃²F\n ₃²G\n ₃²H\n ₃⁴P\n ₃⁴F\n\nIn the second case, we see both ₁²D and ₃²D, since there are two ways of coupling 3 d electrons to a ²D symmetry.\n\n\n\n\n\nintermediate_terms(config)\n\nGenerate the intermediate terms for each subshell of config.\n\nExamples\n\njulia> intermediate_terms(c\"1s 2p3\")\n2-element Array{Array{IntermediateTerm{Term,Seniority},1},1}:\n [₁²S]\n [₁²Pᵒ, ₃²Dᵒ, ₃⁴Sᵒ]\n\njulia> intermediate_terms(rc\"3d2 5g3\")\n2-element Array{Array{IntermediateTerm{HalfIntegers.Half{Int64},Seniority},1},1}:\n [₀0, ₂2, ₂4]\n [₁9/2, ₃3/2, ₃5/2, ₃7/2, ₃9/2, ₃11/2, ₃13/2, ₃15/2, ₃17/2, ₃21/2]\n\n\n\n\n\n","category":"function"},{"location":"terms/#Disambiguating-quantum-numbers","page":"Term symbols","title":"Disambiguating quantum numbers","text":"","category":"section"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"The IntermediateTerm type does not specify how to interpret the disambiguating quantum number(s) ν, or even what the type of it should be. In AtomicLevels, we use two different types, depending on the situation:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"A simple Integer. In this case, the quantum number nu must be in the range 1 leq nu leq N_rmterms, where N_rmterms is the multiplicity of the term symbol (i.e. the number of times this term symbol appears for this subshell ell^w or ell_j^w).\nAtomicLevels does not prescribe any further interpretation for the quantum number. It can be used as a simple counter to distinguish the different terms, or the user can define their own mapping from the set of integers to physical states.\nSeniority. In this case the number is interpreted to be Racah's seniority number. This gives the intermediate term a specific physical interpretation, but only works for certain subshells. See the Seniority type for more information.","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"Seniority","category":"page"},{"location":"terms/#AtomicLevels.Seniority","page":"Term symbols","title":"AtomicLevels.Seniority","text":"Seniority(ν)\n\nSeniority is an extra quantum number introduced by Giulio Racah (1943) to disambiguate between terms belonging to a subshell with a specific occupancy, that are assigned the same term symbols. For partially filled f-shells (in LS coupling) or partially filled 92 shells (in jj coupling), seniority alone is not enough to disambiguate all the arising terms.\n\nThe seniority number is defined as the minimum occupancy number ν ∈ n:-2:0 for which the term first appears, e.g. the ²D term first occurs in the d¹ configuration, then twice in the d³ configuration (which will then have the terms ₁²D and ₃²D).\n\n\n\n\n\n","category":"type"},{"location":"terms/#Term-couplings","page":"Term symbols","title":"Term couplings","text":"","category":"section"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"The angular momentum coupling method is based on the vector model, where two angular momenta can be combined via vector addition to form a total angular momentum:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"vecJ = vecL + vecS","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"where the length of the resultant momentum vecJ obeys","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"L-S leq J leq L+S","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"Relations such as these are used to couple the term symbols in both LS and jj coupling; however, not all values of J predicted by the vector model are valid physical states, see couple_terms.","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"To generate the possible terms of a configuration, all the possible terms of the individual subshells, have to be coupled together to form the final terms; this is done from left-to-right. When generating all possible CSFs from a configuration, it is also necessary to find the intermediate couplings of the individual subshells. As an example, if we want to find the possible terms of 3p² 4s 5p², we first find the possible terms of the individual subshells:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> its = intermediate_terms(c\"3p2 4s 5p2\")\n3-element Array{Array{IntermediateTerm{Term,Seniority},1},1}:\n [₀¹S, ₂¹D, ₂³P]\n [₁²S]\n [₀¹S, ₂¹D, ₂³P]","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"where the seniority numbers are indicated as preceding subscripts. We then need to couple each intermediate term of the first subshell with each of the second subshell, and couple each of the resulting terms with each of the third subshell, and so on. E.g. coupling the ₂³P intermediate term with ₁²S produces two terms:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> couple_terms(T\"3P\", T\"2S\")\n2-element Array{Term,1}:\n ²P\n ⁴P","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"each of which need to be coupled with e.g. ₂¹D:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> couple_terms(T\"2P\", T\"1D\")\n3-element Array{Term,1}:\n ²P\n ²D\n ²F\n\njulia> couple_terms(T\"4P\", T\"1D\")\n3-element Array{Term,1}:\n ⁴P\n ⁴D\n ⁴F","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"terms uses couple_terms (through AtomicLevels.final_terms) to produce all possible terms coupling trees, folding from left-to-right:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> a = couple_terms([T\"1S\", T\"1D\", T\"3P\"], [T\"2S\"])\n4-element Array{Term,1}:\n ²S\n ²P\n ²D\n ⁴P\n\njulia> couple_terms(a, [T\"1S\", T\"1D\", T\"3P\"])\n12-element Array{Term,1}:\n ²S\n ²P\n ²D\n ²F\n ²G\n ⁴S\n ⁴P\n ⁴D\n ⁴F\n ⁶S\n ⁶P\n ⁶D","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"which gives the same result as","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> terms(c\"3p2 4s 5p2\")\n12-element Array{Term,1}:\n ²S\n ²P\n ²D\n ²F\n ²G\n ⁴S\n ⁴P\n ⁴D\n ⁴F\n ⁶S\n ⁶P\n ⁶D","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"Note that for the generation of final terms, the intermediate terms need not be kept (and their seniority is not important). However, for the generation of CSFs, we need to form all possible combinations of intermediate terms for each subshell, and couple them, again left-to-right, to form all possible coupling chains (each one corresponding to a unique physical state). E.g. for the last term of each subshell of 3p² 4s 5p²","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> last.(its)\n3-element Array{IntermediateTerm{Term,Seniority},1}:\n ₂³P\n ₁²S\n ₂³P","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"we find the following chains:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> intermediate_couplings(last.(its))\n15-element Array{Array{Term,1},1}:\n [¹S, ³P, ²P, ²S]\n [¹S, ³P, ²P, ²P]\n [¹S, ³P, ²P, ²D]\n [¹S, ³P, ²P, ⁴S]\n [¹S, ³P, ²P, ⁴P]\n [¹S, ³P, ²P, ⁴D]\n [¹S, ³P, ⁴P, ²S]\n [¹S, ³P, ⁴P, ²P]\n [¹S, ³P, ⁴P, ²D]\n [¹S, ³P, ⁴P, ⁴S]\n [¹S, ³P, ⁴P, ⁴P]\n [¹S, ³P, ⁴P, ⁴D]\n [¹S, ³P, ⁴P, ⁶S]\n [¹S, ³P, ⁴P, ⁶P]\n [¹S, ³P, ⁴P, ⁶D]","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"couple_terms\nAtomicLevels.final_terms\nintermediate_couplings","category":"page"},{"location":"terms/#AtomicLevels.couple_terms","page":"Term symbols","title":"AtomicLevels.couple_terms","text":"couple_terms(t1, t2)\n\nGenerate all possible coupling terms between t1 and t2.  It is assumed that t1 and t2 originate from non-equivalent electrons (i.e. from different subshells), since the vector model does not predict correct term couplings for equivalent electrons; some of the generated terms would violate the Pauli principle; cf. Cowan p. 108–109.\n\nExamples\n\njulia> couple_terms(T\"1Po\", T\"2Se\")\n1-element Array{Term,1}:\n ²Pᵒ\n\njulia> couple_terms(T\"3Po\", T\"2Se\")\n2-element Array{Term,1}:\n ²Pᵒ\n ⁴Pᵒ\n\njulia> couple_terms(T\"3Po\", T\"2De\")\n6-element Array{Term,1}:\n ²Pᵒ\n ²Dᵒ\n ²Fᵒ\n ⁴Pᵒ\n ⁴Dᵒ\n ⁴Fᵒ\n\n\n\n\n\ncouple_terms(t1s, t2s)\n\nGenerate all coupling between all terms in t1s and all terms in t2s.\n\n\n\n\n\n","category":"function"},{"location":"terms/#AtomicLevels.final_terms","page":"Term symbols","title":"AtomicLevels.final_terms","text":"final_terms(ts::Vector{<:Vector{<:Union{Term,Real}}})\n\nGenerate all possible final terms from the vector of vectors of individual subshell terms by coupling from left to right.\n\nExamples\n\njulia> ts = [[T\"1S\", T\"3S\"], [T\"2P\", T\"2D\"]]\n2-element Array{Array{Term,1},1}:\n [¹S, ³S]\n [²P, ²D]\n\njulia> AtomicLevels.final_terms(ts)\n4-element Array{Term,1}:\n ²P\n ²D\n ⁴P\n ⁴D\n\n\n\n\n\n","category":"function"},{"location":"terms/#AtomicLevels.intermediate_couplings","page":"Term symbols","title":"AtomicLevels.intermediate_couplings","text":"intermediate_couplings(its::Vector{IntermediateTerm,Integer,HalfInteger}, t₀ = T\"1S\")\n\nGenerate all intermediate coupling trees from the vector of intermediate terms its, starting from the initial term t₀.\n\nExamples\n\njulia> intermediate_couplings([IntermediateTerm(T\"2S\", 1), IntermediateTerm(T\"2D\", 1)])\n2-element Array{Array{Term,1},1}:\n [¹S, ²S, ¹D]\n [¹S, ²S, ³D]\n\n\n\n\n\nintermediate_couplings(J::Vector{<:Real}, j₀ = 0)\n\nExamples\n\njulia> intermediate_couplings([1//2, 3//2])\n2-element Array{Array{HalfIntegers.Half{Int64},1},1}:\n [0, 1/2, 1]\n [0, 1/2, 2]\n\n\n\n\n\n","category":"function"},{"location":"terms/#Levels-and-States","page":"Term symbols","title":"Levels & States","text":"","category":"section"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"Coupling L and S to a total J, as discussed under Term couplings above, yields a Level; in jj coupling, final term of the CSF already has its final J given.  In both coupling schemes, the same values of final J will result, but via different intermediate couplings. As an example, we will consider the configuration 1s2p, which in the LS and jj coupling schemes has the following CSFs:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> csls = csfs(c\"1s 2p\")\n2-element Array{CSF{Orbital{Int64},Term,Seniority},1}:\n 1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-\n 1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-\n\njulia> csjj = vcat(csfs(rc\"1s 2p\"), csfs(rc\"1s 2p-\"))\n4-element Array{CSF{RelativisticOrbital{Int64},HalfIntegers.Half{Int64},Seniority},1}:\n 1s(₁1/2|1/2) 2p(₁3/2|1)-\n 1s(₁1/2|1/2) 2p(₁3/2|2)-\n 1s(₁1/2|1/2) 2p-(₁1/2|0)-\n 1s(₁1/2|1/2) 2p-(₁1/2|1)-","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"If we now generate the permissible Levels, we find the valid values of J, i.e. 0, 2times 1, and 2:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> levels.(csls)\n2-element Array{Array{Level{Orbital{Int64},Term,Seniority},1},1}:\n [|1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1⟩]\n [|1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 0⟩, |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 1⟩, |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 2⟩]\n\njulia> levels.(csjj)\n4-element Array{Array{Level{RelativisticOrbital{Int64},HalfIntegers.Half{Int64},Seniority},1},1}:\n [|1s(₁1/2|1/2) 2p(₁3/2|1)-, J = 1⟩]\n [|1s(₁1/2|1/2) 2p(₁3/2|2)-, J = 2⟩]\n [|1s(₁1/2|1/2) 2p-(₁1/2|0)-, J = 0⟩]\n [|1s(₁1/2|1/2) 2p-(₁1/2|1)-, J = 1⟩]","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"Level\nweight(l::Level)\nJ_range\nlevels","category":"page"},{"location":"terms/#AtomicLevels.Level","page":"Term symbols","title":"AtomicLevels.Level","text":"Level(csf, J)\n\nGiven a CSF with a final Term, a Level additionally specifies a total angular momentum J. By further specifying a projection quantum number M_J, we get a State.\n\n\n\n\n\n","category":"type"},{"location":"terms/#AtomicLevels.weight-Tuple{Level}","page":"Term symbols","title":"AtomicLevels.weight","text":"weight(l::Level)\n\nReturns the statistical weight of the Level l, i.e. the number of possible microstates: 2J+1.\n\nExample\n\njulia> l = Level(first(csfs(c\"1s 2p\")), 1)\n|1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1⟩\n\njulia> weight(l)\n3\n\n\n\n\n\n","category":"method"},{"location":"terms/#AtomicLevels.J_range","page":"Term symbols","title":"AtomicLevels.J_range","text":"J_range(term::Term)\n\nList the permissible values of the total angular momentum J for term.\n\nExamples\n\njulia> J_range(T\"¹S\")\n0:0\n\njulia> J_range(T\"²S\")\n1/2:1/2\n\njulia> J_range(T\"³P\")\n0:2\n\njulia> J_range(T\"²D\")\n3/2:5/2\n\n\n\n\n\nJ_range(J)\n\nThe permissible range of the total angular momentum J in jj coupling is simply the value of J for the final term.\n\n\n\n\n\n","category":"function"},{"location":"terms/#AtomicLevels.levels","page":"Term symbols","title":"AtomicLevels.levels","text":"levels(csf)\n\nGenerate all permissible Levels given csf.\n\nExamples\n\njulia> levels.(csfs(c\"1s 2p\"))\n2-element Array{Array{Level{Orbital{Int64},Term,Seniority},1},1}:\n [|1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1⟩]\n [|1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 0⟩, |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 1⟩, |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 2⟩]\n\njulia> levels.(csfs(rc\"1s 2p\"))\n2-element Array{Array{Level{RelativisticOrbital{Int64},HalfIntegers.Half{Int64},Seniority},1},1}:\n [|1s(₁1/2|1/2) 2p(₁3/2|1)-, J = 1⟩]\n [|1s(₁1/2|1/2) 2p(₁3/2|2)-, J = 2⟩]\n\njulia> levels.(csfs(rc\"1s 2p-\"))\n2-element Array{Array{Level{RelativisticOrbital{Int64},HalfIntegers.Half{Int64},Seniority},1},1}:\n [|1s(₁1/2|1/2) 2p-(₁1/2|0)-, J = 0⟩]\n [|1s(₁1/2|1/2) 2p-(₁1/2|1)-, J = 1⟩]\n\n\n\n\n\n","category":"function"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"Similarly, by additionally specifying the projection quantum number M_J, we get a fully quantified State. In the same way, the permissible values of M_J must agree between the coupling schemes, sorting by M_J for clarity:","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"julia> sort(reduce(vcat, reduce(vcat, states.(csls))), by=s->s.M_J)\n12-element Array{State{Orbital{Int64},Term,Seniority},1}:\n |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 2, M_J = -2⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1, M_J = -1⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 1, M_J = -1⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 2, M_J = -1⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1, M_J = 0⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 0, M_J = 0⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 1, M_J = 0⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 2, M_J = 0⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1, M_J = 1⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 1, M_J = 1⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 2, M_J = 1⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|³Pᵒ)-, J = 2, M_J = 2⟩\n\njulia> sort(reduce(vcat, reduce(vcat, states.(csjj))), by=s->s.M_J)\n12-element Array{State{RelativisticOrbital{Int64},HalfIntegers.Half{Int64},Seniority},1}:\n |1s(₁1/2|1/2) 2p(₁3/2|2)-, J = 2, M_J = -2⟩\n |1s(₁1/2|1/2) 2p(₁3/2|1)-, J = 1, M_J = -1⟩\n |1s(₁1/2|1/2) 2p(₁3/2|2)-, J = 2, M_J = -1⟩\n |1s(₁1/2|1/2) 2p-(₁1/2|1)-, J = 1, M_J = -1⟩\n |1s(₁1/2|1/2) 2p(₁3/2|1)-, J = 1, M_J = 0⟩\n |1s(₁1/2|1/2) 2p(₁3/2|2)-, J = 2, M_J = 0⟩\n |1s(₁1/2|1/2) 2p-(₁1/2|0)-, J = 0, M_J = 0⟩\n |1s(₁1/2|1/2) 2p-(₁1/2|1)-, J = 1, M_J = 0⟩\n |1s(₁1/2|1/2) 2p(₁3/2|1)-, J = 1, M_J = 1⟩\n |1s(₁1/2|1/2) 2p(₁3/2|2)-, J = 2, M_J = 1⟩\n |1s(₁1/2|1/2) 2p-(₁1/2|1)-, J = 1, M_J = 1⟩\n |1s(₁1/2|1/2) 2p(₁3/2|2)-, J = 2, M_J = 2⟩","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"State\nstates","category":"page"},{"location":"terms/#AtomicLevels.State","page":"Term symbols","title":"AtomicLevels.State","text":"State(level, M_J)\n\nA states defines, in addition to the total angular momentum J of level, its projection M_Jin -JJ.\n\n\n\n\n\n","category":"type"},{"location":"terms/#AtomicLevels.states","page":"Term symbols","title":"AtomicLevels.states","text":"states(level)\n\nGenerate all permissible State given level.\n\nExample\n\njulia> l = Level(first(csfs(c\"1s 2p\")), 1)\n|1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1⟩\n\njulia> states(l)\n3-element Array{State{Orbital{Int64},Term,Seniority},1}:\n |1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1, M_J = -1⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1, M_J = 0⟩\n |1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1, M_J = 1⟩\n\n\n\n\n\nstates(csf)\n\nDirectly generate all permissible States for csf.\n\nExample\n\njulia> c = first(csfs(c\"1s 2p\"))\n1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-\n\njulia> states(c)\n1-element Array{Array{State{Orbital{Int64},Term,Seniority},1},1}:\n [|1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1, M_J = -1⟩, |1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1, M_J = 0⟩, |1s(₁²S|²S) 2p(₁²Pᵒ|¹Pᵒ)-, J = 1, M_J = 1⟩]\n\n\n\n\n\n","category":"function"},{"location":"terms/#Index","page":"Term symbols","title":"Index","text":"","category":"section"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"Pages = [\"terms.md\"]","category":"page"},{"location":"terms/","page":"Term symbols","title":"Term symbols","text":"DocTestSetup = nothing","category":"page"},{"location":"#AtomicLevels.jl","page":"Home","title":"AtomicLevels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AtomicLevels provides a collections of types and methods to facilitate working with atomic states (or, more generally, states with spherical symmetry), both in the relativistic (eigenstates of J = L + S) and non-relativistic (eigenstates on L and S separately) frameworks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Orbitals and orbital subshells\nConfigurations\nConfiguration state functions (CSFs)\nTerm symbols","category":"page"},{"location":"","page":"Home","title":"Home","text":"The aim is to make sure that the types used to label and store information about atomic states are both efficient and user-friendly at the same time. In addition, it also provides various utility methods, such as generation of a list CSFs corresponding to a given configuration, serialization of orbitals and configurations, methods for introspecting physical quantities etc.","category":"page"},{"location":"#Usage-examples","page":"Home","title":"Usage examples","text":"","category":"section"},{"location":"#Orbitals","page":"Home","title":"Orbitals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AtomicLevels","category":"page"},{"location":"","page":"Home","title":"Home","text":"A single orbital can be constructed using string macros","category":"page"},{"location":"","page":"Home","title":"Home","text":"orbitals = o\"2s\", ro\"5f-\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Various methods are provided to look up the properties of the orbitals","category":"page"},{"location":"","page":"Home","title":"Home","text":"for o in orbitals\n    @info \"Orbital: $o :: $(typeof(o))\" parity(o) degeneracy(o) angular_momenta(o)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also create a range of orbitals quickly using the @os_str (or @ros_str) string macros","category":"page"},{"location":"","page":"Home","title":"Home","text":"os\"5[d] 6[s-p] k[7-10]\"","category":"page"},{"location":"#Configurations","page":"Home","title":"Configurations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AtomicLevels","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ground state of hydrogen and helium.","category":"page"},{"location":"","page":"Home","title":"Home","text":"c\"1s\",(c\"1s2\",c\"[He]\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ground state configuration of xenon, in relativistic notation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Xe = rc\"[Kr] 5s2 5p6\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"As we see above, by default, the krypton core is declared “closed”. This is useful for calculations when the core should be frozen. We can “open” it by affixing *.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Xe = c\"[Kr]* 5s2 5p6\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the 5p shell was broken up into 2 5p- electrons and 4 5p electrons. If we are not filling the shell, occupancy of the spin-up and spin-down electrons has to be given separately.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Xe⁺ = rc\"[Kr] 5s2 5p-2 5p3\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is also possible to work with “continuum orbitals”, where the main quantum number is replaced by a Symbol.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Xe⁺e = rc\"[Kr] 5s2 5p-2 5p3 ks\"","category":"page"},{"location":"#Excitations","page":"Home","title":"Excitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AtomicLevels","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can easily generate all possible excitations from a reference configuration. If no extra orbitals are specified, only those that are “open” within the reference set will be considered.","category":"page"},{"location":"","page":"Home","title":"Home","text":"excited_configurations(rc\"[Kr] 5s2 5p-2 5p3\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"By appending virtual orbitals, we can generate excitations to configurations beyond those spanned by the reference set.","category":"page"},{"location":"","page":"Home","title":"Home","text":"excited_configurations(rc\"[Kr] 5s2 5p-2 5p3\", ros\"5[d] 6[s-p]\"...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Again, using the “continuum orbitals”, it is possible to generate the state space accessible via one-photon transitions from the ground state.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Xe⁺e = excited_configurations(rc\"[Kr] 5s2 5p6\", ros\"k[s-d]\"...,\n                              max_excitations=:singles,\n                              keep_parity=false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then query for the bound and continuum orbitals thus.","category":"page"},{"location":"","page":"Home","title":"Home","text":"map(Xe⁺e) do c\n    b = bound(c)\n    num_electrons(b) => b\nend\nmap(Xe⁺e) do c\n    b = continuum(c)\n    num_electrons(b) => b\nend","category":"page"},{"location":"#Term-symbol-calculation","page":"Home","title":"Term symbol calculation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AtomicLevels","category":"page"},{"location":"","page":"Home","title":"Home","text":"Overview of angular momentum coupling on Wikipedia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"LS-coupling. This is done purely non-relativistic, i.e. 2p- is considered equivalent to 2p.","category":"page"},{"location":"","page":"Home","title":"Home","text":"terms(c\"1s\")\nterms(c\"[Kr] 5s2 5p5\")\nterms(c\"[Kr] 5s2 5p4 6s 7g\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"jj-coupling. jj-coupling is implemented slightly differently, it calculates the possible J values resulting from coupling n equivalent electrons in all combinations allowed by the Pauli principle.","category":"page"},{"location":"","page":"Home","title":"Home","text":"intermediate_terms(ro\"1s\", 1)\nintermediate_terms(ro\"5p\", 2)\nintermediate_terms(ro\"7g\", 3)","category":"page"},{"location":"#Configuration-state-functions","page":"Home","title":"Configuration state functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AtomicLevels","category":"page"},{"location":"","page":"Home","title":"Home","text":"CSFs are formed from electronic configurations and their possible term couplings (along with intermediate terms, resulting from unfilled subshells).","category":"page"},{"location":"","page":"Home","title":"Home","text":"sort(vcat(csfs(rc\"3s 3p2\")..., csfs(rc\"3s 3p- 3p\")...))","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"note: Note\nThe functions, methods and types documented here are not part of the public API.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"CurrentModule = AtomicLevels\nDocTestSetup = quote\n    using AtomicLevels\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [AtomicLevels]\nPublic = false\nFilter = fn -> !in(fn, [Base.parse, Base.fill, Base.fill!]) &&\n    fn != AtomicLevels.xu_terms","category":"page"},{"location":"internals/#AtomicLevels.MQ","page":"Internals","title":"AtomicLevels.MQ","text":"const MQ = Union{Int,Symbol}\n\nDefines the possible types that may represent the main quantum number. It can either be an non-negative integer or a Symbol value (generally used to label continuum electrons).\n\n\n\n\n\n","category":"type"},{"location":"internals/#AtomicLevels.final_terms-Union{Tuple{Array{#s40,1} where #s40<:(Array{#s38,1} where #s38<:T)}, Tuple{T}} where T<:Union{Term, Real}","page":"Internals","title":"AtomicLevels.final_terms","text":"final_terms(ts::Vector{<:Vector{<:Union{Term,Real}}})\n\nGenerate all possible final terms from the vector of vectors of individual subshell terms by coupling from left to right.\n\nExamples\n\njulia> ts = [[T\"1S\", T\"3S\"], [T\"2P\", T\"2D\"]]\n2-element Array{Array{Term,1},1}:\n [¹S, ³S]\n [²P, ²D]\n\njulia> AtomicLevels.final_terms(ts)\n4-element Array{Term,1}:\n ²P\n ²D\n ⁴P\n ⁴D\n\n\n\n\n\n","category":"method"},{"location":"internals/#AtomicLevels.get_noble_core_name-Union{Tuple{Configuration{O}}, Tuple{O}} where O","page":"Internals","title":"AtomicLevels.get_noble_core_name","text":"get_noble_core_name(config::Configuration)\n\nReturns the name of the noble gas with the most electrons whose configuration still forms the first part of the closed part of config, or nothing if no such element is found.\n\njulia> AtomicLevels.get_noble_core_name(c\"[He] 2s2\")\n\"He\"\n\njulia> AtomicLevels.get_noble_core_name(c\"1s2c 2s2c 2p6c 3s2c\")\n\"Ne\"\n\njulia> AtomicLevels.get_noble_core_name(c\"1s2\") === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"internals/#AtomicLevels.mqtype-Union{Tuple{Orbital{MQ}}, Tuple{MQ}} where MQ","page":"Internals","title":"AtomicLevels.mqtype","text":"mqtype(::Orbital{MQ}) = MQ\n\nReturns the main quantum number type of an Orbital.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AtomicLevels.mqtype-Union{Tuple{RelativisticOrbital{MQ}}, Tuple{MQ}} where MQ","page":"Internals","title":"AtomicLevels.mqtype","text":"mqtype(::RelativisticOrbital{MQ}) = MQ\n\nReturns the main quantum number type of a RelativisticOrbital.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AtomicLevels.orbital_priority-Union{Tuple{O₂}, Tuple{O₁}, Tuple{Function,Configuration{O₁},Array{O₂,1}}} where O₂<:AbstractOrbital where O₁<:AbstractOrbital","page":"Internals","title":"AtomicLevels.orbital_priority","text":"orbital_priority(fun, orig_cfg, orbitals)\n\nGenerate priorities for the substitution orbitals, i.e. the preferred ordering of the orbitals in configurations excited from orig_cfg. fun can optionally transform the labels of substitution orbitals, in which case they will be ordered just after their parent orbital in the source configuration; otherwise they will be appended to the priority list.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AtomicLevels.rconfigurations_from_orbital-Tuple{Orbital,Integer}","page":"Internals","title":"AtomicLevels.rconfigurations_from_orbital","text":"rconfigurations_from_orbital(orbital::Orbital, occupancy)\n\nGenerate all Configurations with relativistic orbitals corresponding to the non-relativistic version of the orbital with a given occupancy.\n\nExamples\n\njulia> AtomicLevels.rconfigurations_from_orbital(o\"3p\", 2)\n3-element Array{Configuration{#s21} where #s21<:RelativisticOrbital,1}:\n 3p-²\n 3p- 3p\n 3p²\n\n\n\n\n\n","category":"method"},{"location":"internals/#AtomicLevels.rconfigurations_from_orbital-Union{Tuple{N}, Tuple{N,Int64,Int64}} where N<:Union{Int64, Symbol}","page":"Internals","title":"AtomicLevels.rconfigurations_from_orbital","text":"rconfigurations_from_orbital(n, ℓ, occupancy)\n\nGenerate all Configurations with relativistic orbitals corresponding to the non-relativistic orbital with n and ℓ quantum numbers, with given occupancy.\n\nExamples\n\njulia> AtomicLevels.rconfigurations_from_orbital(3, 1, 2)\n3-element Array{Configuration{#s21} where #s21<:RelativisticOrbital,1}:\n 3p-²\n 3p- 3p\n 3p²\n\n\n\n\n\n","category":"method"},{"location":"internals/#AtomicLevels.sorted-Tuple{Configuration}","page":"Internals","title":"AtomicLevels.sorted","text":"sorted(cfg::Configuration)\n\nReturns cfg if it is already sorted or a sorted copy otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.:+-Union{Tuple{O₂}, Tuple{O₁}, Tuple{O}, Tuple{Configuration{O₁},Configuration{O₂}}} where O₂<:O where O₁<:O where O<:AbstractOrbital","page":"Internals","title":"Base.:+","text":"+(::Configuration, ::Configuration)\n\nAdd two configurations together. If both configuration have an orbital, the number of electrons gets added together, but in this case the status of the orbitals must match.\n\njulia> c\"1s\" + c\"2s\"\n1s 2s\n\njulia> c\"1s\" + c\"1s\"\n1s²\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.:--Union{Tuple{O₂}, Tuple{O₁}, Tuple{O}, Tuple{Configuration{O₁},O₂}, Tuple{Configuration{O₁},O₂,Int64}} where O₂<:O where O₁<:O where O<:AbstractOrbital","page":"Internals","title":"Base.:-","text":"-(configuration::Configuration, orbital::AbstractOrbital[, n=1])\n\nRemove n electrons in the orbital orbital from the configuration configuration. If the orbital had previously been :closed or :inactive, it will now be :open.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.:==-Union{Tuple{O}, Tuple{Configuration{#s19} where #s19<:O,Configuration{#s18} where #s18<:O}} where O<:AbstractOrbital","page":"Internals","title":"Base.:==","text":"==(a::Configuration, b::Configuration)\n\nTests if configurations a and b are the same, considering orbital occupancy, ordering, and states.\n\nExamples\n\njulia> c\"1s 2s\" == c\"1s 2s\"\ntrue\n\njulia> c\"1s 2s\" == c\"1s 2si\"\nfalse\n\njulia> c\"1s 2s\" == c\"2s 1s\"\nfalse\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.close-Tuple{Configuration}","page":"Internals","title":"Base.close","text":"close(c::Configuration)\n\nReturn a corresponding configuration where where all the orbitals are marked :closed.\n\nSee also: close!\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.delete!-Union{Tuple{O}, Tuple{Configuration{O},O}} where O<:AbstractOrbital","page":"Internals","title":"Base.delete!","text":"delete!(c::Configuration, o::AbstractOrbital)\n\nRemove the entire subshell corresponding to orbital o from configuration c.\n\njulia> delete!(c\"[Ar] 4s2 3d10 4p2\", o\"4s\")\n[Ar]ᶜ 3d¹⁰ 4p²\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.filter-Tuple{Function,Configuration}","page":"Internals","title":"Base.filter","text":"filter(f, c::Configuration) -> Configuration\n\nFilter out the orbitals from configuration c for which the predicate f returns false. The predicate f needs to take three arguments: orbital, occupancy and state.\n\njulia> filter((o,occ,s) -> o.ℓ == 1, c\"[Kr]\")\n2p⁶ᶜ 3p⁶ᶜ 4p⁶ᶜ\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.in-Union{Tuple{O}, Tuple{O,Configuration{O}}} where O<:AbstractOrbital","page":"Internals","title":"Base.in","text":"in(o::AbstractOrbital, c::Configuration) -> Bool\n\nChecks if orbital o is part of configuration c.\n\njulia> in(o\"2s\", c\"1s2 2s2\")\ntrue\n\njulia> o\"2p\" ∈ c\"1s2 2s2\"\nfalse\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.isless-Tuple{Orbital,Orbital}","page":"Internals","title":"Base.isless","text":"isless(a::Orbital, b::Orbital)\n\nCompares the orbitals a and b to decide which one comes before the other in a configuration.\n\nExamples\n\njulia> o\"1s\" < o\"2s\"\ntrue\n\njulia> o\"1s\" < o\"2p\"\ntrue\n\njulia> o\"ks\" < o\"2p\"\nfalse\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.issorted-Tuple{Configuration}","page":"Internals","title":"Base.issorted","text":"issorted(cfg::Configuration)\n\nTests if the orbitals of cfg is sorted.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.replace-Union{Tuple{O₃}, Tuple{O₂}, Tuple{O₁}, Tuple{O}, Tuple{Configuration{O₁},Pair{O₂,O₃}}} where O₃<:O where O₂<:O where O₁<:O where O<:AbstractOrbital","page":"Internals","title":"Base.replace","text":"replace(conf, a => b[; append=false])\n\nSubstitute one electron in orbital a of conf by one electron in orbital b. If conf is unsorted the substitution is performed in-place, unless append, in which case the new orbital is appended instead.\n\nExamples\n\njulia> replace(c\"1s2 2s\", o\"1s\" => o\"2p\")\n1s 2p 2s\n\njulia> replace(c\"1s2 2s\", o\"1s\" => o\"2p\", append=true)\n1s 2s 2p\n\njulia> replace(c\"1s2 2s\"s, o\"1s\" => o\"2p\")\n1s 2s 2p\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.sort-Tuple{Configuration}","page":"Internals","title":"Base.sort","text":"sort(cfg::Configuration)\n\nReturns a sorted copy of cfg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Internal-implementation-of-term-multiplicity-calculation","page":"Internals","title":"Internal implementation of term multiplicity calculation","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"AtomicLevels.jl uses the algorithm presented in","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Alternative mathematical technique to determine LS spectral terms by Xu Renjun and Dai Zhenwen, published in JPhysB, 2006. doi:10.1088/0953-4075/39/16/007","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"to compute the multiplicity of individual subshells in LS-coupling, beyond the trivial cases of a single electron or a filled subshell. These routines need not be used directly, instead use terms and count_terms.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"In the following, S=2SinmathbbZ and M_S=2M_SinmathbbZ, as in the original article.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"AtomicLevels.Xu.X\nAtomicLevels.Xu.A\nAtomicLevels.Xu.f\nAtomicLevels.xu_terms","category":"page"},{"location":"internals/#AtomicLevels.Xu.X","page":"Internals","title":"AtomicLevels.Xu.X","text":"X(N, ℓ, S′, L)\n\nCalculate the multiplicity of the term ^2S+1L (S=2S) for the orbital ℓ with occupancy N, according to the formula:\n\nbeginaligned\nX(N ell S L) =+ A(N ellellSL)\n- A(N ellellSL+1)\n+A(N ellellS+2L+1)\n- A(N ellellS+2L)\nendaligned\n\nNote that this is not correct for filled (empty) shells, for which the only possible term trivially is ¹S.\n\nExamples\n\njulia> AtomicLevels.Xu.X(1, 0, 1, 0) # Multiplicity of ²S term for s¹\n1\n\njulia> AtomicLevels.Xu.X(3, 3, 1, 3) # Multiplicity of ²D term for d³\n2\n\n\n\n\n\n","category":"function"},{"location":"internals/#AtomicLevels.Xu.A","page":"Internals","title":"AtomicLevels.Xu.A","text":"A(Nellell_bM_SM_L) obeys four different cases:\n\nCase 1\n\nM_S=1, M_Lleqell, and N=1:\n\nA(1ellell_b1M_L) = 1\n\nCase 2\n\nM_S=2-N4-NN-2, M_L leq fleft(fracN-M_S2-1right)+fleft(fracN+M_S2-1right), and 1Nleq 2ell+1:\n\nbeginaligned\nA(NellellM_SM_L) =\nsum_M_L-maxleft-fleft(fracN-M_S2-1right)M_L-fleft(fracN+M_S2-1right)right\n^minleftfleft(fracN-M_S2-1right)M_L+fleft(fracN+M_S2-1right)right\nBiggAleft(fracN-M_S2ellellfracN-M_S2M_L-right)\ntimes\nAleft(fracN+M_S2ellellfracN+M_S2M_L-M_L-right)Bigg\nendaligned\n\nCase 3\n\nM_S=N, M_Lleq f(N-1), and 1Nleq 2ell+1:\n\nA(Nellell_bNM_L) =\nsum_M_L_I = leftlfloorfracM_L-1N+fracN+12rightrfloor\n^minell_bM_L+f(N-2)\nA(N-1ellM_L_I-1N-1M_L-M_L_I)\n\nCase 4\n\nelse:\n\nA(Nellell_bM_SM_L) = 0\n\n\n\n\n\n","category":"function"},{"location":"internals/#AtomicLevels.Xu.f","page":"Internals","title":"AtomicLevels.Xu.f","text":"f(n,ℓ)\n\nf(nell)=begincases\ndisplaystylesum_m=0^n ell-m  ngeq0\n0  n0\nendcases\n\n\n\n\n\n","category":"function"},{"location":"internals/#AtomicLevels.xu_terms","page":"Internals","title":"AtomicLevels.xu_terms","text":"xu_terms(ℓ, w, p)\n\nReturn all term symbols for the orbital ℓʷ and parity p; the term multiplicity is computed using AtomicLevels.Xu.X.\n\nExamples\n\njulia> AtomicLevels.xu_terms(3, 3, parity(c\"3d3\"))\n17-element Array{Term,1}:\n ²P\n ²D\n ²D\n ²F\n ²F\n ²G\n ²G\n ²H\n ²H\n ²I\n ²K\n ²L\n ⁴S\n ⁴D\n ⁴F\n ⁴G\n ⁴I\n\n\n\n\n\n","category":"function"},{"location":"internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"}]
}
